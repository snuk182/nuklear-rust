/* automatically generated by rust-bindgen */
#![allow(dead_code,non_camel_case_types,non_upper_case_globals,non_snake_case)]
#![cfg_attr(feature = "cargo-clippy", allow(transmute_ptr_to_ptr,should_implement_trait,trivially_copy_pass_by_ref))]

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const NK_UNDEFINED: f32 = -1.;
pub const NK_UTF_INVALID: ::std::os::raw::c_uint = 65533;
pub const NK_UTF_SIZE: ::std::os::raw::c_uint = 4;
pub const NK_INPUT_MAX: ::std::os::raw::c_uint = 16;
pub const NK_MAX_NUMBER_BUFFER: ::std::os::raw::c_uint = 64;
pub const NK_SCROLLBAR_HIDING_TIMEOUT: f32 = 4.;
pub const NK_TEXTEDIT_UNDOSTATECOUNT: ::std::os::raw::c_uint = 99;
pub const NK_TEXTEDIT_UNDOCHARCOUNT: ::std::os::raw::c_uint = 999;
pub const NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS: ::std::os::raw::c_uint = 16;
pub const NK_CHART_MAX_SLOT: ::std::os::raw::c_uint = 4;
pub const NK_WINDOW_MAX_NAME: ::std::os::raw::c_uint = 64;
pub const NK_BUTTON_BEHAVIOR_STACK_SIZE: ::std::os::raw::c_uint = 8;
pub const NK_FONT_STACK_SIZE: ::std::os::raw::c_uint = 8;
pub const NK_STYLE_ITEM_STACK_SIZE: ::std::os::raw::c_uint = 16;
pub const NK_FLOAT_STACK_SIZE: ::std::os::raw::c_uint = 32;
pub const NK_VECTOR_STACK_SIZE: ::std::os::raw::c_uint = 16;
pub const NK_FLAGS_STACK_SIZE: ::std::os::raw::c_uint = 32;
pub const NK_COLOR_STACK_SIZE: ::std::os::raw::c_uint = 32;
pub const NK_PI: f32 = ::std::f32::consts::PI;
pub const NK_MAX_FLOAT_PRECISION: ::std::os::raw::c_uint = 2;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type nk_char = i8;
pub type nk_uchar = u8;
pub type nk_byte = u8;
pub type nk_short = i16;
pub type nk_ushort = u16;
pub type nk_int = i32;
pub type nk_uint = u32;
pub type nk_size = usize;
pub type nk_ptr = usize;
pub type nk_hash = nk_uint;
pub type nk_flags = nk_uint;
pub type nk_rune = nk_uint;
pub type _dummy_array0 = [::std::os::raw::c_char; 1usize];
pub type _dummy_array1 = [::std::os::raw::c_char; 1usize];
pub type _dummy_array2 = [::std::os::raw::c_char; 1usize];
pub type _dummy_array3 = [::std::os::raw::c_char; 1usize];
pub type _dummy_array4 = [::std::os::raw::c_char; 1usize];
pub type _dummy_array5 = [::std::os::raw::c_char; 1usize];
pub type _dummy_array6 = [::std::os::raw::c_char; 1usize];
pub type _dummy_array7 = [::std::os::raw::c_char; 1usize];
pub type _dummy_array8 = [::std::os::raw::c_char; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_buffer {
    pub marker: [nk_buffer_marker; 2usize],
    pub pool: nk_allocator,
    pub type_: nk_allocation_type,
    pub memory: nk_memory,
    pub grow_factor: f32,
    pub allocated: nk_size,
    pub needed: nk_size,
    pub calls: nk_size,
    pub size: nk_size,
}
#[test]
fn bindgen_test_layout_nk_buffer() {
    assert_eq!(::std::mem::size_of::<nk_buffer>() , 120usize , concat ! (
               "Size of: " , stringify ! ( nk_buffer ) ));
    assert_eq! (::std::mem::align_of::<nk_buffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_buffer ) ) . marker as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_buffer ) , "::" ,
                stringify ! ( marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_buffer ) ) . pool as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_buffer ) , "::" ,
                stringify ! ( pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_buffer ) ) . type_ as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_buffer ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_buffer ) ) . memory as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_buffer ) , "::" ,
                stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_buffer ) ) . grow_factor as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_buffer ) , "::" ,
                stringify ! ( grow_factor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_buffer ) ) . allocated as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_buffer ) , "::" ,
                stringify ! ( allocated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_buffer ) ) . needed as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_buffer ) , "::" ,
                stringify ! ( needed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_buffer ) ) . calls as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_buffer ) , "::" ,
                stringify ! ( calls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_buffer ) ) . size as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_buffer ) , "::" ,
                stringify ! ( size ) ));
}
impl Clone for nk_buffer {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_buffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_allocator {
    pub userdata: nk_handle,
    pub alloc: nk_plugin_alloc,
    pub free: nk_plugin_free,
}
#[test]
fn bindgen_test_layout_nk_allocator() {
    assert_eq!(::std::mem::size_of::<nk_allocator>() , 24usize , concat ! (
               "Size of: " , stringify ! ( nk_allocator ) ));
    assert_eq! (::std::mem::align_of::<nk_allocator>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_allocator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_allocator ) ) . userdata as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_allocator ) , "::" ,
                stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_allocator ) ) . alloc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_allocator ) , "::" ,
                stringify ! ( alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_allocator ) ) . free as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_allocator ) , "::" ,
                stringify ! ( free ) ));
}
impl Clone for nk_allocator {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_allocator {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_buffer {
    pub base: *mut nk_buffer,
    pub clip: nk_rect,
    pub use_clipping: ::std::os::raw::c_int,
    pub userdata: nk_handle,
    pub begin: nk_size,
    pub end: nk_size,
    pub last: nk_size,
}
#[test]
fn bindgen_test_layout_nk_command_buffer() {
    assert_eq!(::std::mem::size_of::<nk_command_buffer>() , 64usize , concat !
               ( "Size of: " , stringify ! ( nk_command_buffer ) ));
    assert_eq! (::std::mem::align_of::<nk_command_buffer>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nk_command_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_buffer ) ) . base as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_buffer ) ,
                "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_buffer ) ) . clip as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_buffer ) ,
                "::" , stringify ! ( clip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_buffer ) ) . use_clipping as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_buffer ) ,
                "::" , stringify ! ( use_clipping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_buffer ) ) . userdata as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_buffer ) ,
                "::" , stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_buffer ) ) . begin as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_buffer ) ,
                "::" , stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_buffer ) ) . end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_buffer ) ,
                "::" , stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_buffer ) ) . last as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_buffer ) ,
                "::" , stringify ! ( last ) ));
}
impl Clone for nk_command_buffer {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_buffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_draw_command {
    pub elem_count: ::std::os::raw::c_uint,
    pub clip_rect: nk_rect,
    pub texture: nk_handle,
    pub userdata: nk_handle,
}
#[test]
fn bindgen_test_layout_nk_draw_command() {
    assert_eq!(::std::mem::size_of::<nk_draw_command>() , 40usize , concat ! (
               "Size of: " , stringify ! ( nk_draw_command ) ));
    assert_eq! (::std::mem::align_of::<nk_draw_command>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_draw_command ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_command ) ) . elem_count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_command ) ,
                "::" , stringify ! ( elem_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_command ) ) . clip_rect as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_command ) ,
                "::" , stringify ! ( clip_rect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_command ) ) . texture as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_command ) ,
                "::" , stringify ! ( texture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_command ) ) . userdata as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_command ) ,
                "::" , stringify ! ( userdata ) ));
}
impl Clone for nk_draw_command {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_convert_config {
    pub global_alpha: f32,
    pub line_AA: nk_anti_aliasing,
    pub shape_AA: nk_anti_aliasing,
    pub circle_segment_count: ::std::os::raw::c_uint,
    pub arc_segment_count: ::std::os::raw::c_uint,
    pub curve_segment_count: ::std::os::raw::c_uint,
    pub null: nk_draw_null_texture,
    pub vertex_layout: *const nk_draw_vertex_layout_element,
    pub vertex_size: nk_size,
    pub vertex_alignment: nk_size,
}
#[test]
fn bindgen_test_layout_nk_convert_config() {
    assert_eq!(::std::mem::size_of::<nk_convert_config>() , 64usize , concat !
               ( "Size of: " , stringify ! ( nk_convert_config ) ));
    assert_eq! (::std::mem::align_of::<nk_convert_config>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nk_convert_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_convert_config ) ) . global_alpha as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_convert_config ) ,
                "::" , stringify ! ( global_alpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_convert_config ) ) . line_AA as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_convert_config ) ,
                "::" , stringify ! ( line_AA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_convert_config ) ) . shape_AA as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_convert_config ) ,
                "::" , stringify ! ( shape_AA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_convert_config ) ) .
                circle_segment_count as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( nk_convert_config ) ,
                "::" , stringify ! ( circle_segment_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_convert_config ) ) . arc_segment_count
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_convert_config ) ,
                "::" , stringify ! ( arc_segment_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_convert_config ) ) .
                curve_segment_count as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! ( nk_convert_config ) ,
                "::" , stringify ! ( curve_segment_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_convert_config ) ) . null as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_convert_config ) ,
                "::" , stringify ! ( null ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_convert_config ) ) . vertex_layout as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_convert_config ) ,
                "::" , stringify ! ( vertex_layout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_convert_config ) ) . vertex_size as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_convert_config ) ,
                "::" , stringify ! ( vertex_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_convert_config ) ) . vertex_alignment
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_convert_config ) ,
                "::" , stringify ! ( vertex_alignment ) ));
}
impl Clone for nk_convert_config {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_convert_config {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_item {
    pub type_: nk_style_item_type,
    pub data: nk_style_item_data,
}
#[test]
fn bindgen_test_layout_nk_style_item() {
    assert_eq!(::std::mem::size_of::<nk_style_item>() , 32usize , concat ! (
               "Size of: " , stringify ! ( nk_style_item ) ));
    assert_eq! (::std::mem::align_of::<nk_style_item>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_style_item ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_item ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_item ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_item ) ) . data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_item ) , "::"
                , stringify ! ( data ) ));
}
impl Clone for nk_style_item {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_item {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct nk_text_edit {
    pub clip: nk_clipboard,
    pub string: nk_str,
    pub filter: nk_plugin_filter,
    pub scrollbar: nk_vec2,
    pub cursor: ::std::os::raw::c_int,
    pub select_start: ::std::os::raw::c_int,
    pub select_end: ::std::os::raw::c_int,
    pub mode: ::std::os::raw::c_uchar,
    pub cursor_at_end_of_line: ::std::os::raw::c_uchar,
    pub initialized: ::std::os::raw::c_uchar,
    pub has_preferred_x: ::std::os::raw::c_uchar,
    pub single_line: ::std::os::raw::c_uchar,
    pub active: ::std::os::raw::c_uchar,
    pub padding1: ::std::os::raw::c_uchar,
    pub preferred_x: f32,
    pub undo: nk_text_undo_state,
}
#[test]
fn bindgen_test_layout_nk_text_edit() {
    assert_eq!(::std::mem::size_of::<nk_text_edit>() , 5384usize , concat ! (
               "Size of: " , stringify ! ( nk_text_edit ) ));
    assert_eq! (::std::mem::align_of::<nk_text_edit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_text_edit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . clip as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( clip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . string as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . filter as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . scrollbar as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( scrollbar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . cursor as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . select_start as *
                const _ as usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( select_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . select_end as * const
                _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( select_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . mode as * const _ as
                usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . cursor_at_end_of_line
                as * const _ as usize } , 181usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( cursor_at_end_of_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . initialized as * const
                _ as usize } , 182usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( initialized ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . has_preferred_x as *
                const _ as usize } , 183usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( has_preferred_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . single_line as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( single_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . active as * const _ as
                usize } , 185usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . padding1 as * const _
                as usize } , 186usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( padding1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . preferred_x as * const
                _ as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( preferred_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_edit ) ) . undo as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_edit ) , "::" ,
                stringify ! ( undo ) ));
}
impl Default for nk_text_edit {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_draw_list {
    pub clip_rect: nk_rect,
    pub circle_vtx: [nk_vec2; 12usize],
    pub config: nk_convert_config,
    pub buffer: *mut nk_buffer,
    pub vertices: *mut nk_buffer,
    pub elements: *mut nk_buffer,
    pub element_count: ::std::os::raw::c_uint,
    pub vertex_count: ::std::os::raw::c_uint,
    pub cmd_count: ::std::os::raw::c_uint,
    pub cmd_offset: nk_size,
    pub path_count: ::std::os::raw::c_uint,
    pub path_offset: ::std::os::raw::c_uint,
    pub userdata: nk_handle,
}
#[test]
fn bindgen_test_layout_nk_draw_list() {
    assert_eq!(::std::mem::size_of::<nk_draw_list>() , 240usize , concat ! (
               "Size of: " , stringify ! ( nk_draw_list ) ));
    assert_eq! (::std::mem::align_of::<nk_draw_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_draw_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . clip_rect as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( clip_rect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . circle_vtx as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( circle_vtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . config as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . buffer as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . vertices as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( vertices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . elements as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( elements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . element_count as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( element_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . vertex_count as *
                const _ as usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( vertex_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . cmd_count as * const _
                as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( cmd_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . cmd_offset as * const
                _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( cmd_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . path_count as * const
                _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( path_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . path_offset as * const
                _ as usize } , 228usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( path_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_list ) ) . userdata as * const _
                as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_list ) , "::" ,
                stringify ! ( userdata ) ));
}
impl Clone for nk_draw_list {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_draw_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_user_font {
    pub userdata: nk_handle,
    pub height: f32,
    pub width: nk_text_width_f,
    pub query: nk_query_font_glyph_f,
    pub texture: nk_handle,
}
#[test]
fn bindgen_test_layout_nk_user_font() {
    assert_eq!(::std::mem::size_of::<nk_user_font>() , 40usize , concat ! (
               "Size of: " , stringify ! ( nk_user_font ) ));
    assert_eq! (::std::mem::align_of::<nk_user_font>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_user_font ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_user_font ) ) . userdata as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_user_font ) , "::" ,
                stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_user_font ) ) . height as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_user_font ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_user_font ) ) . width as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_user_font ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_user_font ) ) . query as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_user_font ) , "::" ,
                stringify ! ( query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_user_font ) ) . texture as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_user_font ) , "::" ,
                stringify ! ( texture ) ));
}
impl Clone for nk_user_font {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_user_font {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_panel {
    pub type_: nk_panel_type,
    pub flags: nk_flags,
    pub bounds: nk_rect,
    pub offset_x: *mut nk_uint,
    pub offset_y: *mut nk_uint,
    pub at_x: f32,
    pub at_y: f32,
    pub max_x: f32,
    pub footer_height: f32,
    pub header_height: f32,
    pub border: f32,
    pub has_scrolling: ::std::os::raw::c_uint,
    pub clip: nk_rect,
    pub menu: nk_menu_state,
    pub row: nk_row_layout,
    pub chart: nk_chart,
    pub popup_buffer: nk_popup_buffer,
    pub buffer: *mut nk_command_buffer,
    pub parent: *mut nk_panel,
}
#[test]
fn bindgen_test_layout_nk_panel() {
    assert_eq!(::std::mem::size_of::<nk_panel>() , 480usize , concat ! (
               "Size of: " , stringify ! ( nk_panel ) ));
    assert_eq! (::std::mem::align_of::<nk_panel>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_panel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . flags as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . bounds as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( bounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . offset_x as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( offset_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . offset_y as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( offset_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . at_x as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( at_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . at_y as * const _ as usize
                } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( at_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . max_x as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( max_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . footer_height as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( footer_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . header_height as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( header_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . border as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . has_scrolling as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( has_scrolling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . clip as * const _ as usize
                } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( clip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . menu as * const _ as usize
                } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( menu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . row as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . chart as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( chart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . popup_buffer as * const _
                as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( popup_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . buffer as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_panel ) ) . parent as * const _ as
                usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_panel ) , "::" ,
                stringify ! ( parent ) ));
}
impl Clone for nk_panel {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_panel {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct nk_context {
    pub input: nk_input,
    pub style: nk_style,
    pub memory: nk_buffer,
    pub clip: nk_clipboard,
    pub last_widget_state: nk_flags,
    pub button_behavior: nk_button_behavior,
    pub stacks: nk_configuration_stacks,
    pub delta_time_seconds: f32,
    pub draw_list: nk_draw_list,
    pub userdata: nk_handle,
    pub text_edit: nk_text_edit,
    pub overlay: nk_command_buffer,
    pub build: ::std::os::raw::c_int,
    pub use_pool: ::std::os::raw::c_int,
    pub pool: nk_pool,
    pub begin: *mut nk_window,
    pub end: *mut nk_window,
    pub active: *mut nk_window,
    pub current: *mut nk_window,
    pub freelist: *mut nk_page_element,
    pub count: ::std::os::raw::c_uint,
    pub seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nk_context() {
    assert_eq!(::std::mem::size_of::<nk_context>() , 16608usize , concat ! (
               "Size of: " , stringify ! ( nk_context ) ));
    assert_eq! (::std::mem::align_of::<nk_context>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . input as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . style as * const _ as
                usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( style ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . memory as * const _ as
                usize } , 7880usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . clip as * const _ as
                usize } , 8000usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( clip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . last_widget_state as *
                const _ as usize } , 8024usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( last_widget_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . button_behavior as *
                const _ as usize } , 8028usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( button_behavior ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . stacks as * const _ as
                usize } , 8032usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( stacks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . delta_time_seconds as *
                const _ as usize } , 10776usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( delta_time_seconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . draw_list as * const _
                as usize } , 10784usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( draw_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . userdata as * const _ as
                usize } , 11024usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . text_edit as * const _
                as usize } , 11032usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( text_edit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . overlay as * const _ as
                usize } , 16416usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( overlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . build as * const _ as
                usize } , 16480usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( build ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . use_pool as * const _ as
                usize } , 16484usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( use_pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . pool as * const _ as
                usize } , 16488usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . begin as * const _ as
                usize } , 16560usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . end as * const _ as
                usize } , 16568usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . active as * const _ as
                usize } , 16576usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . current as * const _ as
                usize } , 16584usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . freelist as * const _ as
                usize } , 16592usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( freelist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . count as * const _ as
                usize } , 16600usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_context ) ) . seq as * const _ as
                usize } , 16604usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_context ) , "::" ,
                stringify ! ( seq ) ));
}
impl Default for nk_context {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_draw_vertex_layout_element {
    pub attribute: nk_draw_vertex_layout_attribute,
    pub format: nk_draw_vertex_layout_format,
    pub offset: nk_size,
}
#[test]
fn bindgen_test_layout_nk_draw_vertex_layout_element() {
    assert_eq!(::std::mem::size_of::<nk_draw_vertex_layout_element>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( nk_draw_vertex_layout_element ) ));
    assert_eq! (::std::mem::align_of::<nk_draw_vertex_layout_element>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( nk_draw_vertex_layout_element
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_vertex_layout_element ) ) .
                attribute as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_draw_vertex_layout_element ) , "::" , stringify ! (
                attribute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_vertex_layout_element ) ) .
                format as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_draw_vertex_layout_element ) , "::" , stringify ! ( format
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_vertex_layout_element ) ) .
                offset as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_draw_vertex_layout_element ) , "::" , stringify ! ( offset
                ) ));
}
impl Clone for nk_draw_vertex_layout_element {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_draw_vertex_layout_element {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_button {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub text_background: nk_color,
    pub text_normal: nk_color,
    pub text_hover: nk_color,
    pub text_active: nk_color,
    pub text_alignment: nk_flags,
    pub border: f32,
    pub rounding: f32,
    pub padding: nk_vec2,
    pub image_padding: nk_vec2,
    pub touch_padding: nk_vec2,
    pub userdata: nk_handle,
    pub draw_begin: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut nk_command_buffer,
                                                               userdata:
                                                                   nk_handle)>,
    pub draw_end: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut nk_command_buffer,
                                                             userdata:
                                                                 nk_handle)>,
}
#[test]
fn bindgen_test_layout_nk_style_button() {
    assert_eq!(::std::mem::size_of::<nk_style_button>() , 176usize , concat !
               ( "Size of: " , stringify ! ( nk_style_button ) ));
    assert_eq! (::std::mem::align_of::<nk_style_button>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_style_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . normal as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . hover as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . active as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . border_color as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . text_background as
                * const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( text_background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . text_normal as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( text_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . text_hover as *
                const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( text_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . text_active as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( text_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . text_alignment as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( text_alignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . border as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . rounding as * const
                _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . padding as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . image_padding as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( image_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . touch_padding as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( touch_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . userdata as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . draw_begin as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( draw_begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_button ) ) . draw_end as * const
                _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_button ) ,
                "::" , stringify ! ( draw_end ) ));
}
impl Clone for nk_style_button {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_button {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_toggle {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub cursor_normal: nk_style_item,
    pub cursor_hover: nk_style_item,
    pub text_normal: nk_color,
    pub text_hover: nk_color,
    pub text_active: nk_color,
    pub text_background: nk_color,
    pub text_alignment: nk_flags,
    pub padding: nk_vec2,
    pub touch_padding: nk_vec2,
    pub spacing: f32,
    pub border: f32,
    pub userdata: nk_handle,
    pub draw_begin: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut nk_command_buffer,
                                                               arg2:
                                                                   nk_handle)>,
    pub draw_end: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut nk_command_buffer,
                                                             arg2:
                                                                 nk_handle)>,
}
#[test]
fn bindgen_test_layout_nk_style_toggle() {
    assert_eq!(::std::mem::size_of::<nk_style_toggle>() , 240usize , concat !
               ( "Size of: " , stringify ! ( nk_style_toggle ) ));
    assert_eq! (::std::mem::align_of::<nk_style_toggle>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_style_toggle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . normal as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . hover as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . active as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . border_color as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . cursor_normal as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( cursor_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . cursor_hover as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( cursor_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . text_normal as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( text_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . text_hover as *
                const _ as usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( text_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . text_active as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( text_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . text_background as
                * const _ as usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( text_background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . text_alignment as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( text_alignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . padding as * const
                _ as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . touch_padding as *
                const _ as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( touch_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . spacing as * const
                _ as usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( spacing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . border as * const _
                as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . userdata as * const
                _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . draw_begin as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( draw_begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_toggle ) ) . draw_end as * const
                _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_toggle ) ,
                "::" , stringify ! ( draw_end ) ));
}
impl Clone for nk_style_toggle {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_toggle {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_selectable {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub pressed: nk_style_item,
    pub normal_active: nk_style_item,
    pub hover_active: nk_style_item,
    pub pressed_active: nk_style_item,
    pub text_normal: nk_color,
    pub text_hover: nk_color,
    pub text_pressed: nk_color,
    pub text_normal_active: nk_color,
    pub text_hover_active: nk_color,
    pub text_pressed_active: nk_color,
    pub text_background: nk_color,
    pub text_alignment: nk_flags,
    pub rounding: f32,
    pub padding: nk_vec2,
    pub touch_padding: nk_vec2,
    pub image_padding: nk_vec2,
    pub userdata: nk_handle,
    pub draw_begin: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut nk_command_buffer,
                                                               arg2:
                                                                   nk_handle)>,
    pub draw_end: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut nk_command_buffer,
                                                             arg2:
                                                                 nk_handle)>,
}
#[test]
fn bindgen_test_layout_nk_style_selectable() {
    assert_eq!(::std::mem::size_of::<nk_style_selectable>() , 280usize ,
               concat ! ( "Size of: " , stringify ! ( nk_style_selectable )
               ));
    assert_eq! (::std::mem::align_of::<nk_style_selectable>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_style_selectable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . normal as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . hover as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . pressed as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( pressed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . normal_active
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( normal_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . hover_active as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( hover_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . pressed_active
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( pressed_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . text_normal as
                * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( text_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . text_hover as *
                const _ as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( text_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . text_pressed as
                * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( text_pressed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) .
                text_normal_active as * const _ as usize } , 204usize , concat
                ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( text_normal_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) .
                text_hover_active as * const _ as usize } , 208usize , concat
                ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( text_hover_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) .
                text_pressed_active as * const _ as usize } , 212usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( text_pressed_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . text_background
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( text_background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . text_alignment
                as * const _ as usize } , 220usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( text_alignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . rounding as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . padding as *
                const _ as usize } , 228usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . touch_padding
                as * const _ as usize } , 236usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( touch_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . image_padding
                as * const _ as usize } , 244usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( image_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . userdata as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . draw_begin as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( draw_begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_selectable ) ) . draw_end as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_selectable ) ,
                "::" , stringify ! ( draw_end ) ));
}
impl Clone for nk_style_selectable {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_selectable {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nk_style_slide([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_progress {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub cursor_normal: nk_style_item,
    pub cursor_hover: nk_style_item,
    pub cursor_active: nk_style_item,
    pub cursor_border_color: nk_color,
    pub rounding: f32,
    pub border: f32,
    pub cursor_border: f32,
    pub cursor_rounding: f32,
    pub padding: nk_vec2,
    pub userdata: nk_handle,
    pub draw_begin: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut nk_command_buffer,
                                                               arg2:
                                                                   nk_handle)>,
    pub draw_end: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut nk_command_buffer,
                                                             arg2:
                                                                 nk_handle)>,
}
#[test]
fn bindgen_test_layout_nk_style_progress() {
    assert_eq!(::std::mem::size_of::<nk_style_progress>() , 256usize , concat
               ! ( "Size of: " , stringify ! ( nk_style_progress ) ));
    assert_eq! (::std::mem::align_of::<nk_style_progress>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nk_style_progress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . normal as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . hover as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . active as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . border_color as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . cursor_normal as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( cursor_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . cursor_hover as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( cursor_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . cursor_active as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( cursor_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) .
                cursor_border_color as * const _ as usize } , 200usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( cursor_border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . rounding as *
                const _ as usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . border as * const
                _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . cursor_border as
                * const _ as usize } , 212usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( cursor_border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . cursor_rounding
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( cursor_rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . padding as *
                const _ as usize } , 220usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . userdata as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . draw_begin as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( draw_begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_progress ) ) . draw_end as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_progress ) ,
                "::" , stringify ! ( draw_end ) ));
}
impl Clone for nk_style_progress {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_progress {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_scrollbar {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub cursor_normal: nk_style_item,
    pub cursor_hover: nk_style_item,
    pub cursor_active: nk_style_item,
    pub cursor_border_color: nk_color,
    pub border: f32,
    pub rounding: f32,
    pub border_cursor: f32,
    pub rounding_cursor: f32,
    pub padding: nk_vec2,
    pub show_buttons: ::std::os::raw::c_int,
    pub inc_button: nk_style_button,
    pub dec_button: nk_style_button,
    pub inc_symbol: nk_symbol_type,
    pub dec_symbol: nk_symbol_type,
    pub userdata: nk_handle,
    pub draw_begin: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut nk_command_buffer,
                                                               arg2:
                                                                   nk_handle)>,
    pub draw_end: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut nk_command_buffer,
                                                             arg2:
                                                                 nk_handle)>,
}
#[test]
fn bindgen_test_layout_nk_style_scrollbar() {
    assert_eq!(::std::mem::size_of::<nk_style_scrollbar>() , 616usize , concat
               ! ( "Size of: " , stringify ! ( nk_style_scrollbar ) ));
    assert_eq! (::std::mem::align_of::<nk_style_scrollbar>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nk_style_scrollbar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . normal as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . hover as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . active as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . border_color as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . cursor_normal as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( cursor_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . cursor_hover as
                * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( cursor_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . cursor_active as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( cursor_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) .
                cursor_border_color as * const _ as usize } , 200usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( cursor_border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . border as *
                const _ as usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . rounding as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . border_cursor as
                * const _ as usize } , 212usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( border_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . rounding_cursor
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( rounding_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . padding as *
                const _ as usize } , 220usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . show_buttons as
                * const _ as usize } , 228usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( show_buttons ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . inc_button as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( inc_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . dec_button as *
                const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( dec_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . inc_symbol as *
                const _ as usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( inc_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . dec_symbol as *
                const _ as usize } , 588usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( dec_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . userdata as *
                const _ as usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . draw_begin as *
                const _ as usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( draw_begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_scrollbar ) ) . draw_end as *
                const _ as usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_scrollbar ) ,
                "::" , stringify ! ( draw_end ) ));
}
impl Clone for nk_style_scrollbar {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_scrollbar {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_edit {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub scrollbar: nk_style_scrollbar,
    pub cursor_normal: nk_color,
    pub cursor_hover: nk_color,
    pub cursor_text_normal: nk_color,
    pub cursor_text_hover: nk_color,
    pub text_normal: nk_color,
    pub text_hover: nk_color,
    pub text_active: nk_color,
    pub selected_normal: nk_color,
    pub selected_hover: nk_color,
    pub selected_text_normal: nk_color,
    pub selected_text_hover: nk_color,
    pub border: f32,
    pub rounding: f32,
    pub cursor_size: f32,
    pub scrollbar_size: nk_vec2,
    pub padding: nk_vec2,
    pub row_padding: f32,
}
#[test]
fn bindgen_test_layout_nk_style_edit() {
    assert_eq!(::std::mem::size_of::<nk_style_edit>() , 800usize , concat ! (
               "Size of: " , stringify ! ( nk_style_edit ) ));
    assert_eq! (::std::mem::align_of::<nk_style_edit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_style_edit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . normal as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . hover as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . active as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . border_color as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . scrollbar as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( scrollbar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . cursor_normal as *
                const _ as usize } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( cursor_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . cursor_hover as *
                const _ as usize } , 724usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( cursor_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . cursor_text_normal as
                * const _ as usize } , 728usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( cursor_text_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . cursor_text_hover as
                * const _ as usize } , 732usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( cursor_text_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . text_normal as *
                const _ as usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( text_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . text_hover as * const
                _ as usize } , 740usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( text_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . text_active as *
                const _ as usize } , 744usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( text_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . selected_normal as *
                const _ as usize } , 748usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( selected_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . selected_hover as *
                const _ as usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( selected_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . selected_text_normal
                as * const _ as usize } , 756usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( selected_text_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . selected_text_hover
                as * const _ as usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( selected_text_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . border as * const _
                as usize } , 764usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . rounding as * const _
                as usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . cursor_size as *
                const _ as usize } , 772usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( cursor_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . scrollbar_size as *
                const _ as usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( scrollbar_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . padding as * const _
                as usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_edit ) ) . row_padding as *
                const _ as usize } , 792usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_edit ) , "::"
                , stringify ! ( row_padding ) ));
}
impl Clone for nk_style_edit {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_edit {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_property {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub label_normal: nk_color,
    pub label_hover: nk_color,
    pub label_active: nk_color,
    pub sym_left: nk_symbol_type,
    pub sym_right: nk_symbol_type,
    pub border: f32,
    pub rounding: f32,
    pub padding: nk_vec2,
    pub edit: nk_style_edit,
    pub inc_button: nk_style_button,
    pub dec_button: nk_style_button,
    pub userdata: nk_handle,
    pub draw_begin: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut nk_command_buffer,
                                                               arg2:
                                                                   nk_handle)>,
    pub draw_end: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut nk_command_buffer,
                                                             arg2:
                                                                 nk_handle)>,
}
#[test]
fn bindgen_test_layout_nk_style_property() {
    assert_eq!(::std::mem::size_of::<nk_style_property>() , 1312usize , concat
               ! ( "Size of: " , stringify ! ( nk_style_property ) ));
    assert_eq! (::std::mem::align_of::<nk_style_property>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nk_style_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . normal as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . hover as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . active as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . border_color as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . label_normal as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( label_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . label_hover as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( label_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . label_active as *
                const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( label_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . sym_left as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( sym_left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . sym_right as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( sym_right ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . border as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . rounding as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . padding as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . edit as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( edit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . inc_button as *
                const _ as usize } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( inc_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . dec_button as *
                const _ as usize } , 1112usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( dec_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . userdata as *
                const _ as usize } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . draw_begin as *
                const _ as usize } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( draw_begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_property ) ) . draw_end as *
                const _ as usize } , 1304usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_property ) ,
                "::" , stringify ! ( draw_end ) ));
}
impl Clone for nk_style_property {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_property {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_chart {
    pub background: nk_style_item,
    pub border_color: nk_color,
    pub selected_color: nk_color,
    pub color: nk_color,
    pub border: f32,
    pub rounding: f32,
    pub padding: nk_vec2,
}
#[test]
fn bindgen_test_layout_nk_style_chart() {
    assert_eq!(::std::mem::size_of::<nk_style_chart>() , 64usize , concat ! (
               "Size of: " , stringify ! ( nk_style_chart ) ));
    assert_eq! (::std::mem::align_of::<nk_style_chart>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_style_chart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_chart ) ) . background as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_chart ) , "::"
                , stringify ! ( background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_chart ) ) . border_color as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_chart ) , "::"
                , stringify ! ( border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_chart ) ) . selected_color as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_chart ) , "::"
                , stringify ! ( selected_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_chart ) ) . color as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_chart ) , "::"
                , stringify ! ( color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_chart ) ) . border as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_chart ) , "::"
                , stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_chart ) ) . rounding as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_chart ) , "::"
                , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_chart ) ) . padding as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_chart ) , "::"
                , stringify ! ( padding ) ));
}
impl Clone for nk_style_chart {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_chart {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_combo {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub label_normal: nk_color,
    pub label_hover: nk_color,
    pub label_active: nk_color,
    pub symbol_normal: nk_color,
    pub symbol_hover: nk_color,
    pub symbol_active: nk_color,
    pub button: nk_style_button,
    pub sym_normal: nk_symbol_type,
    pub sym_hover: nk_symbol_type,
    pub sym_active: nk_symbol_type,
    pub border: f32,
    pub rounding: f32,
    pub content_padding: nk_vec2,
    pub button_padding: nk_vec2,
    pub spacing: nk_vec2,
}
#[test]
fn bindgen_test_layout_nk_style_combo() {
    assert_eq!(::std::mem::size_of::<nk_style_combo>() , 352usize , concat ! (
               "Size of: " , stringify ! ( nk_style_combo ) ));
    assert_eq! (::std::mem::align_of::<nk_style_combo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_style_combo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . normal as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . hover as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . active as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . border_color as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . label_normal as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( label_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . label_hover as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( label_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . label_active as *
                const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( label_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . symbol_normal as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( symbol_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . symbol_hover as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( symbol_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . symbol_active as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( symbol_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . button as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . sym_normal as *
                const _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( sym_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . sym_hover as * const
                _ as usize } , 308usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( sym_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . sym_active as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( sym_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . border as * const _
                as usize } , 316usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . rounding as * const
                _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . content_padding as *
                const _ as usize } , 324usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( content_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . button_padding as *
                const _ as usize } , 332usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( button_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_combo ) ) . spacing as * const _
                as usize } , 340usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_combo ) , "::"
                , stringify ! ( spacing ) ));
}
impl Clone for nk_style_combo {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_combo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_tab {
    pub background: nk_style_item,
    pub border_color: nk_color,
    pub text: nk_color,
    pub tab_maximize_button: nk_style_button,
    pub tab_minimize_button: nk_style_button,
    pub node_maximize_button: nk_style_button,
    pub node_minimize_button: nk_style_button,
    pub sym_minimize: nk_symbol_type,
    pub sym_maximize: nk_symbol_type,
    pub border: f32,
    pub rounding: f32,
    pub indent: f32,
    pub padding: nk_vec2,
    pub spacing: nk_vec2,
}
#[test]
fn bindgen_test_layout_nk_style_tab() {
    assert_eq!(::std::mem::size_of::<nk_style_tab>() , 784usize , concat ! (
               "Size of: " , stringify ! ( nk_style_tab ) ));
    assert_eq! (::std::mem::align_of::<nk_style_tab>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_style_tab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . background as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . border_color as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . text as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . tab_maximize_button as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( tab_maximize_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . tab_minimize_button as
                * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( tab_minimize_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . node_maximize_button
                as * const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( node_maximize_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . node_minimize_button
                as * const _ as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( node_minimize_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . sym_minimize as *
                const _ as usize } , 744usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( sym_minimize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . sym_maximize as *
                const _ as usize } , 748usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( sym_maximize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . border as * const _ as
                usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . rounding as * const _
                as usize } , 756usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . indent as * const _ as
                usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( indent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . padding as * const _
                as usize } , 764usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_tab ) ) . spacing as * const _
                as usize } , 772usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_tab ) , "::" ,
                stringify ! ( spacing ) ));
}
impl Clone for nk_style_tab {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_tab {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_window_header {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub close_button: nk_style_button,
    pub minimize_button: nk_style_button,
    pub close_symbol: nk_symbol_type,
    pub minimize_symbol: nk_symbol_type,
    pub maximize_symbol: nk_symbol_type,
    pub label_normal: nk_color,
    pub label_hover: nk_color,
    pub label_active: nk_color,
    pub align: nk_style_header_align,
    pub padding: nk_vec2,
    pub label_padding: nk_vec2,
    pub spacing: nk_vec2,
}
#[test]
fn bindgen_test_layout_nk_style_window_header() {
    assert_eq!(::std::mem::size_of::<nk_style_window_header>() , 504usize ,
               concat ! ( "Size of: " , stringify ! ( nk_style_window_header )
               ));
    assert_eq! (::std::mem::align_of::<nk_style_window_header>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_style_window_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) . normal as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) . hover as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) . active as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) . close_button
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( close_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) .
                minimize_button as * const _ as usize } , 272usize , concat !
                (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( minimize_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) . close_symbol
                as * const _ as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( close_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) .
                minimize_symbol as * const _ as usize } , 452usize , concat !
                (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( minimize_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) .
                maximize_symbol as * const _ as usize } , 456usize , concat !
                (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( maximize_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) . label_normal
                as * const _ as usize } , 460usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( label_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) . label_hover
                as * const _ as usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( label_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) . label_active
                as * const _ as usize } , 468usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( label_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) . align as *
                const _ as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) . padding as *
                const _ as usize } , 476usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) .
                label_padding as * const _ as usize } , 484usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( label_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window_header ) ) . spacing as *
                const _ as usize } , 492usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window_header
                ) , "::" , stringify ! ( spacing ) ));
}
impl Clone for nk_style_window_header {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_window_header {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_window {
    pub header: nk_style_window_header,
    pub fixed_background: nk_style_item,
    pub background: nk_color,
    pub border_color: nk_color,
    pub popup_border_color: nk_color,
    pub combo_border_color: nk_color,
    pub contextual_border_color: nk_color,
    pub menu_border_color: nk_color,
    pub group_border_color: nk_color,
    pub tooltip_border_color: nk_color,
    pub scaler: nk_style_item,
    pub border: f32,
    pub combo_border: f32,
    pub contextual_border: f32,
    pub menu_border: f32,
    pub group_border: f32,
    pub tooltip_border: f32,
    pub popup_border: f32,
    pub rounding: f32,
    pub spacing: nk_vec2,
    pub scrollbar_size: nk_vec2,
    pub min_size: nk_vec2,
    pub padding: nk_vec2,
    pub group_padding: nk_vec2,
    pub popup_padding: nk_vec2,
    pub combo_padding: nk_vec2,
    pub contextual_padding: nk_vec2,
    pub menu_padding: nk_vec2,
    pub tooltip_padding: nk_vec2,
}
#[test]
fn bindgen_test_layout_nk_style_window() {
    assert_eq!(::std::mem::size_of::<nk_style_window>() , 712usize , concat !
               ( "Size of: " , stringify ! ( nk_style_window ) ));
    assert_eq! (::std::mem::align_of::<nk_style_window>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_style_window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . fixed_background as
                * const _ as usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( fixed_background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . background as *
                const _ as usize } , 536usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . border_color as *
                const _ as usize } , 540usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . popup_border_color
                as * const _ as usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( popup_border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . combo_border_color
                as * const _ as usize } , 548usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( combo_border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) .
                contextual_border_color as * const _ as usize } , 552usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( contextual_border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . menu_border_color
                as * const _ as usize } , 556usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( menu_border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . group_border_color
                as * const _ as usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( group_border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) .
                tooltip_border_color as * const _ as usize } , 564usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( tooltip_border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . scaler as * const _
                as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( scaler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . border as * const _
                as usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . combo_border as *
                const _ as usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( combo_border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . contextual_border
                as * const _ as usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( contextual_border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . menu_border as *
                const _ as usize } , 612usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( menu_border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . group_border as *
                const _ as usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( group_border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . tooltip_border as *
                const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( tooltip_border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . popup_border as *
                const _ as usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( popup_border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . rounding as * const
                _ as usize } , 628usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . spacing as * const
                _ as usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( spacing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . scrollbar_size as *
                const _ as usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( scrollbar_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . min_size as * const
                _ as usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( min_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . padding as * const
                _ as usize } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . group_padding as *
                const _ as usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( group_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . popup_padding as *
                const _ as usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( popup_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . combo_padding as *
                const _ as usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( combo_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . contextual_padding
                as * const _ as usize } , 688usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( contextual_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . menu_padding as *
                const _ as usize } , 696usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( menu_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_window ) ) . tooltip_padding as
                * const _ as usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_window ) ,
                "::" , stringify ! ( tooltip_padding ) ));
}
impl Clone for nk_style_window {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_window {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub const nk_false: _bindgen_ty_1 = _bindgen_ty_1::nk_false;
pub const nk_true: _bindgen_ty_1 = _bindgen_ty_1::nk_true;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 { nk_false = 0, nk_true = 1, }
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_color {
    pub r: nk_byte,
    pub g: nk_byte,
    pub b: nk_byte,
    pub a: nk_byte,
}
#[test]
fn bindgen_test_layout_nk_color() {
    assert_eq!(::std::mem::size_of::<nk_color>() , 4usize , concat ! (
               "Size of: " , stringify ! ( nk_color ) ));
    assert_eq! (::std::mem::align_of::<nk_color>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( nk_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_color ) ) . r as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_color ) , "::" ,
                stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_color ) ) . g as * const _ as usize }
                , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_color ) , "::" ,
                stringify ! ( g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_color ) ) . b as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_color ) , "::" ,
                stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_color ) ) . a as * const _ as usize }
                , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_color ) , "::" ,
                stringify ! ( a ) ));
}
impl Clone for nk_color {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_colorf {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[test]
fn bindgen_test_layout_nk_colorf() {
    assert_eq!(::std::mem::size_of::<nk_colorf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( nk_colorf ) ));
    assert_eq! (::std::mem::align_of::<nk_colorf>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_colorf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_colorf ) ) . r as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_colorf ) , "::" ,
                stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_colorf ) ) . g as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_colorf ) , "::" ,
                stringify ! ( g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_colorf ) ) . b as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_colorf ) , "::" ,
                stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_colorf ) ) . a as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_colorf ) , "::" ,
                stringify ! ( a ) ));
}
impl Clone for nk_colorf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_vec2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_nk_vec2() {
    assert_eq!(::std::mem::size_of::<nk_vec2>() , 8usize , concat ! (
               "Size of: " , stringify ! ( nk_vec2 ) ));
    assert_eq! (::std::mem::align_of::<nk_vec2>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_vec2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_vec2 ) ) . x as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_vec2 ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_vec2 ) ) . y as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_vec2 ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for nk_vec2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_vec2i {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_nk_vec2i() {
    assert_eq!(::std::mem::size_of::<nk_vec2i>() , 4usize , concat ! (
               "Size of: " , stringify ! ( nk_vec2i ) ));
    assert_eq! (::std::mem::align_of::<nk_vec2i>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( nk_vec2i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_vec2i ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_vec2i ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_vec2i ) ) . y as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_vec2i ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for nk_vec2i {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_rect {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[test]
fn bindgen_test_layout_nk_rect() {
    assert_eq!(::std::mem::size_of::<nk_rect>() , 16usize , concat ! (
               "Size of: " , stringify ! ( nk_rect ) ));
    assert_eq! (::std::mem::align_of::<nk_rect>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_rect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_rect ) ) . x as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_rect ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_rect ) ) . y as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_rect ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_rect ) ) . w as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_rect ) , "::" ,
                stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_rect ) ) . h as * const _ as usize } ,
                12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_rect ) , "::" ,
                stringify ! ( h ) ));
}
impl Clone for nk_rect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_recti {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_short,
    pub h: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_nk_recti() {
    assert_eq!(::std::mem::size_of::<nk_recti>() , 8usize , concat ! (
               "Size of: " , stringify ! ( nk_recti ) ));
    assert_eq! (::std::mem::align_of::<nk_recti>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( nk_recti ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_recti ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_recti ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_recti ) ) . y as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_recti ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_recti ) ) . w as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_recti ) , "::" ,
                stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_recti ) ) . h as * const _ as usize }
                , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_recti ) , "::" ,
                stringify ! ( h ) ));
}
impl Clone for nk_recti {
    fn clone(&self) -> Self { *self }
}
pub type nk_glyph = [::std::os::raw::c_char; 4usize];
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_handle {
    pub ptr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub id: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: usize,
}
#[test]
fn bindgen_test_layout_nk_handle() {
    assert_eq!(::std::mem::size_of::<nk_handle>() , 8usize , concat ! (
               "Size of: " , stringify ! ( nk_handle ) ));
    assert_eq! (::std::mem::align_of::<nk_handle>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_handle ) ) . ptr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_handle ) , "::" ,
                stringify ! ( ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_handle ) ) . id as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_handle ) , "::" ,
                stringify ! ( id ) ));
}
impl Clone for nk_handle {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_image {
    pub handle: nk_handle,
    pub w: ::std::os::raw::c_ushort,
    pub h: ::std::os::raw::c_ushort,
    pub region: [::std::os::raw::c_ushort; 4usize],
}
#[test]
fn bindgen_test_layout_nk_image() {
    assert_eq!(::std::mem::size_of::<nk_image>() , 24usize , concat ! (
               "Size of: " , stringify ! ( nk_image ) ));
    assert_eq! (::std::mem::align_of::<nk_image>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_image ) ) . handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_image ) , "::" ,
                stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_image ) ) . w as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_image ) , "::" ,
                stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_image ) ) . h as * const _ as usize }
                , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_image ) , "::" ,
                stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_image ) ) . region as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_image ) , "::" ,
                stringify ! ( region ) ));
}
impl Clone for nk_image {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_cursor {
    pub img: nk_image,
    pub size: nk_vec2,
    pub offset: nk_vec2,
}
#[test]
fn bindgen_test_layout_nk_cursor() {
    assert_eq!(::std::mem::size_of::<nk_cursor>() , 40usize , concat ! (
               "Size of: " , stringify ! ( nk_cursor ) ));
    assert_eq! (::std::mem::align_of::<nk_cursor>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_cursor ) ) . img as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_cursor ) , "::" ,
                stringify ! ( img ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_cursor ) ) . size as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_cursor ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_cursor ) ) . offset as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_cursor ) , "::" ,
                stringify ! ( offset ) ));
}
impl Clone for nk_cursor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_scroll {
    pub x: nk_uint,
    pub y: nk_uint,
}
#[test]
fn bindgen_test_layout_nk_scroll() {
    assert_eq!(::std::mem::size_of::<nk_scroll>() , 8usize , concat ! (
               "Size of: " , stringify ! ( nk_scroll ) ));
    assert_eq! (::std::mem::align_of::<nk_scroll>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_scroll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_scroll ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_scroll ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_scroll ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_scroll ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for nk_scroll {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_heading { NK_UP = 0, NK_RIGHT = 1, NK_DOWN = 2, NK_LEFT = 3, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_button_behavior { NK_BUTTON_DEFAULT = 0, NK_BUTTON_REPEATER = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_modify { NK_FIXED = 0, NK_MODIFIABLE = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_orientation { NK_VERTICAL = 0, NK_HORIZONTAL = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_collapse_states { NK_MINIMIZED = 0, NK_MAXIMIZED = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_show_states { NK_HIDDEN = 0, NK_SHOWN = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_chart_type {
    NK_CHART_LINES = 0,
    NK_CHART_COLUMN = 1,
    NK_CHART_MAX = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_chart_event { NK_CHART_HOVERING = 1, NK_CHART_CLICKED = 2, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_color_format { NK_RGB = 0, NK_RGBA = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_popup_type { NK_POPUP_STATIC = 0, NK_POPUP_DYNAMIC = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_layout_format { NK_DYNAMIC = 0, NK_STATIC = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_tree_type { NK_TREE_NODE = 0, NK_TREE_TAB = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_anti_aliasing {
    NK_ANTI_ALIASING_OFF = 0,
    NK_ANTI_ALIASING_ON = 1,
}
pub type nk_plugin_alloc =
    ::std::option::Option<unsafe extern "C" fn(arg1: nk_handle,
                                               old:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: nk_size)
                              -> *mut ::std::os::raw::c_void>;
pub type nk_plugin_free =
    ::std::option::Option<unsafe extern "C" fn(arg1: nk_handle,
                                               old:
                                                   *mut ::std::os::raw::c_void)>;
pub type nk_plugin_filter =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const nk_text_edit,
                                               unicode: nk_rune)
                              -> ::std::os::raw::c_int>;
pub type nk_plugin_paste =
    ::std::option::Option<unsafe extern "C" fn(arg1: nk_handle,
                                               arg2: *mut nk_text_edit)>;
pub type nk_plugin_copy =
    ::std::option::Option<unsafe extern "C" fn(arg1: nk_handle,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               len: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_draw_null_texture {
    pub texture: nk_handle,
    pub uv: nk_vec2,
}
#[test]
fn bindgen_test_layout_nk_draw_null_texture() {
    assert_eq!(::std::mem::size_of::<nk_draw_null_texture>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( nk_draw_null_texture )
               ));
    assert_eq! (::std::mem::align_of::<nk_draw_null_texture>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_draw_null_texture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_null_texture ) ) . texture as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_null_texture )
                , "::" , stringify ! ( texture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_draw_null_texture ) ) . uv as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_draw_null_texture )
                , "::" , stringify ! ( uv ) ));
}
impl Clone for nk_draw_null_texture {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_list_view {
    pub begin: ::std::os::raw::c_int,
    pub end: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub total_height: ::std::os::raw::c_int,
    pub ctx: *mut nk_context,
    pub scroll_pointer: *mut nk_uint,
    pub scroll_value: nk_uint,
}
#[test]
fn bindgen_test_layout_nk_list_view() {
    assert_eq!(::std::mem::size_of::<nk_list_view>() , 40usize , concat ! (
               "Size of: " , stringify ! ( nk_list_view ) ));
    assert_eq! (::std::mem::align_of::<nk_list_view>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_list_view ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_list_view ) ) . begin as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_list_view ) , "::" ,
                stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_list_view ) ) . end as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_list_view ) , "::" ,
                stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_list_view ) ) . count as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_list_view ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_list_view ) ) . total_height as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_list_view ) , "::" ,
                stringify ! ( total_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_list_view ) ) . ctx as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_list_view ) , "::" ,
                stringify ! ( ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_list_view ) ) . scroll_pointer as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_list_view ) , "::" ,
                stringify ! ( scroll_pointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_list_view ) ) . scroll_value as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_list_view ) , "::" ,
                stringify ! ( scroll_value ) ));
}
impl Clone for nk_list_view {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_list_view {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_symbol_type {
    NK_SYMBOL_NONE = 0,
    NK_SYMBOL_X = 1,
    NK_SYMBOL_UNDERSCORE = 2,
    NK_SYMBOL_CIRCLE_SOLID = 3,
    NK_SYMBOL_CIRCLE_OUTLINE = 4,
    NK_SYMBOL_RECT_SOLID = 5,
    NK_SYMBOL_RECT_OUTLINE = 6,
    NK_SYMBOL_TRIANGLE_UP = 7,
    NK_SYMBOL_TRIANGLE_DOWN = 8,
    NK_SYMBOL_TRIANGLE_LEFT = 9,
    NK_SYMBOL_TRIANGLE_RIGHT = 10,
    NK_SYMBOL_PLUS = 11,
    NK_SYMBOL_MINUS = 12,
    NK_SYMBOL_MAX = 13,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_keys {
    NK_KEY_NONE = 0,
    NK_KEY_SHIFT = 1,
    NK_KEY_CTRL = 2,
    NK_KEY_DEL = 3,
    NK_KEY_ENTER = 4,
    NK_KEY_TAB = 5,
    NK_KEY_BACKSPACE = 6,
    NK_KEY_COPY = 7,
    NK_KEY_CUT = 8,
    NK_KEY_PASTE = 9,
    NK_KEY_UP = 10,
    NK_KEY_DOWN = 11,
    NK_KEY_LEFT = 12,
    NK_KEY_RIGHT = 13,
    NK_KEY_TEXT_INSERT_MODE = 14,
    NK_KEY_TEXT_REPLACE_MODE = 15,
    NK_KEY_TEXT_RESET_MODE = 16,
    NK_KEY_TEXT_LINE_START = 17,
    NK_KEY_TEXT_LINE_END = 18,
    NK_KEY_TEXT_START = 19,
    NK_KEY_TEXT_END = 20,
    NK_KEY_TEXT_UNDO = 21,
    NK_KEY_TEXT_REDO = 22,
    NK_KEY_TEXT_SELECT_ALL = 23,
    NK_KEY_TEXT_WORD_LEFT = 24,
    NK_KEY_TEXT_WORD_RIGHT = 25,
    NK_KEY_SCROLL_START = 26,
    NK_KEY_SCROLL_END = 27,
    NK_KEY_SCROLL_DOWN = 28,
    NK_KEY_SCROLL_UP = 29,
    NK_KEY_MAX = 30,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_buttons {
    NK_BUTTON_LEFT = 0,
    NK_BUTTON_MIDDLE = 1,
    NK_BUTTON_RIGHT = 2,
    NK_BUTTON_MAX = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_style_colors {
    NK_COLOR_TEXT = 0,
    NK_COLOR_WINDOW = 1,
    NK_COLOR_HEADER = 2,
    NK_COLOR_BORDER = 3,
    NK_COLOR_BUTTON = 4,
    NK_COLOR_BUTTON_HOVER = 5,
    NK_COLOR_BUTTON_ACTIVE = 6,
    NK_COLOR_TOGGLE = 7,
    NK_COLOR_TOGGLE_HOVER = 8,
    NK_COLOR_TOGGLE_CURSOR = 9,
    NK_COLOR_SELECT = 10,
    NK_COLOR_SELECT_ACTIVE = 11,
    NK_COLOR_SLIDER = 12,
    NK_COLOR_SLIDER_CURSOR = 13,
    NK_COLOR_SLIDER_CURSOR_HOVER = 14,
    NK_COLOR_SLIDER_CURSOR_ACTIVE = 15,
    NK_COLOR_PROPERTY = 16,
    NK_COLOR_EDIT = 17,
    NK_COLOR_EDIT_CURSOR = 18,
    NK_COLOR_COMBO = 19,
    NK_COLOR_CHART = 20,
    NK_COLOR_CHART_COLOR = 21,
    NK_COLOR_CHART_COLOR_HIGHLIGHT = 22,
    NK_COLOR_SCROLLBAR = 23,
    NK_COLOR_SCROLLBAR_CURSOR = 24,
    NK_COLOR_SCROLLBAR_CURSOR_HOVER = 25,
    NK_COLOR_SCROLLBAR_CURSOR_ACTIVE = 26,
    NK_COLOR_TAB_HEADER = 27,
    NK_COLOR_COUNT = 28,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_style_cursor {
    NK_CURSOR_ARROW = 0,
    NK_CURSOR_TEXT = 1,
    NK_CURSOR_MOVE = 2,
    NK_CURSOR_RESIZE_VERTICAL = 3,
    NK_CURSOR_RESIZE_HORIZONTAL = 4,
    NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT = 5,
    NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT = 6,
    NK_CURSOR_COUNT = 7,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_widget_layout_states {
    NK_WIDGET_INVALID = 0,
    NK_WIDGET_VALID = 1,
    NK_WIDGET_ROM = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_widget_states {
    NK_WIDGET_STATE_MODIFIED = 2,
    NK_WIDGET_STATE_INACTIVE = 4,
    NK_WIDGET_STATE_ENTERED = 8,
    NK_WIDGET_STATE_HOVER = 16,
    NK_WIDGET_STATE_ACTIVED = 32,
    NK_WIDGET_STATE_LEFT = 64,
    NK_WIDGET_STATE_HOVERED = 18,
    NK_WIDGET_STATE_ACTIVE = 34,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_text_align {
    NK_TEXT_ALIGN_LEFT = 1,
    NK_TEXT_ALIGN_CENTERED = 2,
    NK_TEXT_ALIGN_RIGHT = 4,
    NK_TEXT_ALIGN_TOP = 8,
    NK_TEXT_ALIGN_MIDDLE = 16,
    NK_TEXT_ALIGN_BOTTOM = 32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_text_alignment {
    NK_TEXT_LEFT = 17,
    NK_TEXT_CENTERED = 18,
    NK_TEXT_RIGHT = 20,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_edit_flags {
    NK_EDIT_DEFAULT = 0,
    NK_EDIT_READ_ONLY = 1,
    NK_EDIT_AUTO_SELECT = 2,
    NK_EDIT_SIG_ENTER = 4,
    NK_EDIT_ALLOW_TAB = 8,
    NK_EDIT_NO_CURSOR = 16,
    NK_EDIT_SELECTABLE = 32,
    NK_EDIT_CLIPBOARD = 64,
    NK_EDIT_CTRL_ENTER_NEWLINE = 128,
    NK_EDIT_NO_HORIZONTAL_SCROLL = 256,
    NK_EDIT_ALWAYS_INSERT_MODE = 512,
    NK_EDIT_MULTILINE = 2048,
    NK_EDIT_GOTO_END_ON_ACTIVATE = 4096,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_edit_types {
    NK_EDIT_SIMPLE = 512,
    NK_EDIT_FIELD = 608,
    NK_EDIT_BOX = 2664,
    NK_EDIT_EDITOR = 2152,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_edit_events {
    NK_EDIT_ACTIVE = 1,
    NK_EDIT_INACTIVE = 2,
    NK_EDIT_ACTIVATED = 4,
    NK_EDIT_DEACTIVATED = 8,
    NK_EDIT_COMMITED = 16,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_panel_flags {
    NK_WINDOW_BORDER = 1,
    NK_WINDOW_MOVABLE = 2,
    NK_WINDOW_SCALABLE = 4,
    NK_WINDOW_CLOSABLE = 8,
    NK_WINDOW_MINIMIZABLE = 16,
    NK_WINDOW_NO_SCROLLBAR = 32,
    NK_WINDOW_TITLE = 64,
    NK_WINDOW_SCROLL_AUTO_HIDE = 128,
    NK_WINDOW_BACKGROUND = 256,
    NK_WINDOW_SCALE_LEFT = 512,
}
extern "C" {
    pub fn nk_init_fixed(arg1: *mut nk_context,
                         memory: *mut ::std::os::raw::c_void, size: nk_size,
                         arg2: *const nk_user_font) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_init(arg1: *mut nk_context, arg2: *mut nk_allocator,
                   arg3: *const nk_user_font) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_init_custom(arg1: *mut nk_context, cmds: *mut nk_buffer,
                          pool: *mut nk_buffer, arg2: *const nk_user_font)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_clear(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_free(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_set_user_data(arg1: *mut nk_context, handle: nk_handle);
}
extern "C" {
    pub fn nk_begin(arg1: *mut nk_context,
                    title: *const ::std::os::raw::c_char, bounds: nk_rect,
                    flags: nk_flags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_begin_titled(arg1: *mut nk_context,
                           name: *const ::std::os::raw::c_char,
                           title: *const ::std::os::raw::c_char,
                           bounds: nk_rect, flags: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_end(arg1: *mut nk_context);
}
#[repr(C)]
pub struct nk_window {
    pub seq: ::std::os::raw::c_uint,
    pub name: nk_hash,
    pub name_string: [::std::os::raw::c_char; 64usize],
    pub flags: nk_flags,
    pub bounds: nk_rect,
    pub scrollbar: nk_scroll,
    pub buffer: nk_command_buffer,
    pub layout: *mut nk_panel,
    pub scrollbar_hiding_timer: f32,
    pub property: nk_property_state,
    pub popup: nk_popup_state,
    pub edit: nk_edit_state,
    pub scrolled: ::std::os::raw::c_uint,
    pub tables: *mut nk_table,
    pub table_count: ::std::os::raw::c_ushort,
    pub table_size: ::std::os::raw::c_ushort,
    pub next: *mut nk_window,
    pub prev: *mut nk_window,
    pub parent: *mut nk_window,
}
#[test]
fn bindgen_test_layout_nk_window() {
    assert_eq!(::std::mem::size_of::<nk_window>() , 424usize , concat ! (
               "Size of: " , stringify ! ( nk_window ) ));
    assert_eq! (::std::mem::align_of::<nk_window>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . seq as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . name as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . name_string as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( name_string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . flags as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . bounds as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( bounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . scrollbar as * const _ as
                usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( scrollbar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . buffer as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . layout as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( layout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . scrollbar_hiding_timer as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( scrollbar_hiding_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . property as * const _ as
                usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . popup as * const _ as
                usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( popup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . edit as * const _ as
                usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( edit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . scrolled as * const _ as
                usize } , 380usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( scrolled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . tables as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( tables ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . table_count as * const _
                as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( table_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . table_size as * const _
                as usize } , 394usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( table_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . next as * const _ as
                usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . prev as * const _ as
                usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_window ) ) . parent as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_window ) , "::" ,
                stringify ! ( parent ) ));
}
impl Default for nk_window {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn nk_window_find(ctx: *mut nk_context,
                          name: *const ::std::os::raw::c_char)
     -> *mut nk_window;
}
extern "C" {
    pub fn nk_window_get_bounds(arg1: *const nk_context) -> nk_rect;
}
extern "C" {
    pub fn nk_window_get_position(arg1: *const nk_context) -> nk_vec2;
}
extern "C" {
    pub fn nk_window_get_size(arg1: *const nk_context) -> nk_vec2;
}
extern "C" {
    pub fn nk_window_get_width(arg1: *const nk_context) -> f32;
}
extern "C" {
    pub fn nk_window_get_height(arg1: *const nk_context) -> f32;
}
extern "C" {
    pub fn nk_window_get_panel(arg1: *mut nk_context) -> *mut nk_panel;
}
extern "C" {
    pub fn nk_window_get_content_region(arg1: *mut nk_context) -> nk_rect;
}
extern "C" {
    pub fn nk_window_get_content_region_min(arg1: *mut nk_context) -> nk_vec2;
}
extern "C" {
    pub fn nk_window_get_content_region_max(arg1: *mut nk_context) -> nk_vec2;
}
extern "C" {
    pub fn nk_window_get_content_region_size(arg1: *mut nk_context)
     -> nk_vec2;
}
extern "C" {
    pub fn nk_window_get_canvas(arg1: *mut nk_context)
     -> *mut nk_command_buffer;
}
extern "C" {
    pub fn nk_window_has_focus(arg1: *const nk_context)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_window_is_collapsed(arg1: *mut nk_context,
                                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_window_is_closed(arg1: *mut nk_context,
                               arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_window_is_hidden(arg1: *mut nk_context,
                               arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_window_is_active(arg1: *mut nk_context,
                               arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_window_is_hovered(arg1: *mut nk_context)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_window_is_any_hovered(arg1: *mut nk_context)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_item_is_any_active(arg1: *mut nk_context)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_window_set_bounds(arg1: *mut nk_context, arg2: nk_rect);
}
extern "C" {
    pub fn nk_window_set_position(arg1: *mut nk_context, arg2: nk_vec2);
}
extern "C" {
    pub fn nk_window_set_size(arg1: *mut nk_context, arg2: nk_vec2);
}
extern "C" {
    pub fn nk_window_set_focus(arg1: *mut nk_context,
                               name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nk_window_close(ctx: *mut nk_context,
                           name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nk_window_collapse(arg1: *mut nk_context,
                              name: *const ::std::os::raw::c_char,
                              arg2: nk_collapse_states);
}
extern "C" {
    pub fn nk_window_collapse_if(arg1: *mut nk_context,
                                 name: *const ::std::os::raw::c_char,
                                 arg2: nk_collapse_states,
                                 cond: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_window_show(arg1: *mut nk_context,
                          name: *const ::std::os::raw::c_char,
                          arg2: nk_show_states);
}
extern "C" {
    pub fn nk_window_show_if(arg1: *mut nk_context,
                             name: *const ::std::os::raw::c_char,
                             arg2: nk_show_states,
                             cond: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_layout_row_dynamic(arg1: *mut nk_context, height: f32,
                                 cols: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_layout_row_static(arg1: *mut nk_context, height: f32,
                                item_width: ::std::os::raw::c_int,
                                cols: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_layout_row_begin(arg1: *mut nk_context, arg2: nk_layout_format,
                               row_height: f32, cols: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_layout_row_push(arg1: *mut nk_context, value: f32);
}
extern "C" {
    pub fn nk_layout_row_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_layout_row(arg1: *mut nk_context, arg2: nk_layout_format,
                         height: f32, cols: ::std::os::raw::c_int,
                         ratio: *const f32);
}
extern "C" {
    pub fn nk_layout_row_template_begin(arg1: *mut nk_context, height: f32);
}
extern "C" {
    pub fn nk_layout_row_template_push_dynamic(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_layout_row_template_push_variable(arg1: *mut nk_context,
                                                min_width: f32);
}
extern "C" {
    pub fn nk_layout_row_template_push_static(arg1: *mut nk_context,
                                              width: f32);
}
extern "C" {
    pub fn nk_layout_row_template_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_layout_space_begin(arg1: *mut nk_context,
                                 arg2: nk_layout_format, height: f32,
                                 widget_count: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_layout_space_push(arg1: *mut nk_context, arg2: nk_rect);
}
extern "C" {
    pub fn nk_layout_space_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_layout_space_bounds(arg1: *mut nk_context) -> nk_rect;
}
extern "C" {
    pub fn nk_layout_space_to_screen(arg1: *mut nk_context, arg2: nk_vec2)
     -> nk_vec2;
}
extern "C" {
    pub fn nk_layout_space_to_local(arg1: *mut nk_context, arg2: nk_vec2)
     -> nk_vec2;
}
extern "C" {
    pub fn nk_layout_space_rect_to_screen(arg1: *mut nk_context,
                                          arg2: nk_rect) -> nk_rect;
}
extern "C" {
    pub fn nk_layout_space_rect_to_local(arg1: *mut nk_context, arg2: nk_rect)
     -> nk_rect;
}
extern "C" {
    pub fn nk_layout_ratio_from_pixel(arg1: *mut nk_context, pixel_width: f32)
     -> f32;
}
extern "C" {
    pub fn nk_group_begin(arg1: *mut nk_context,
                          title: *const ::std::os::raw::c_char,
                          arg2: nk_flags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_group_scrolled_offset_begin(arg1: *mut nk_context,
                                          x_offset: *mut nk_uint,
                                          y_offset: *mut nk_uint,
                                          arg2: *const ::std::os::raw::c_char,
                                          arg3: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_group_scrolled_begin(arg1: *mut nk_context,
                                   arg2: *mut nk_scroll,
                                   title: *const ::std::os::raw::c_char,
                                   arg3: nk_flags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_group_scrolled_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_group_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_list_view_begin(arg1: *mut nk_context, out: *mut nk_list_view,
                              id: *const ::std::os::raw::c_char,
                              arg2: nk_flags,
                              row_height: ::std::os::raw::c_int,
                              row_count: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_list_view_end(arg1: *mut nk_list_view);
}
extern "C" {
    pub fn nk_tree_push_hashed(arg1: *mut nk_context, arg2: nk_tree_type,
                               title: *const ::std::os::raw::c_char,
                               initial_state: nk_collapse_states,
                               hash: *const ::std::os::raw::c_char,
                               len: ::std::os::raw::c_int,
                               seed: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_tree_image_push_hashed(arg1: *mut nk_context,
                                     arg2: nk_tree_type, arg3: nk_image,
                                     title: *const ::std::os::raw::c_char,
                                     initial_state: nk_collapse_states,
                                     hash: *const ::std::os::raw::c_char,
                                     len: ::std::os::raw::c_int,
                                     seed: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_tree_pop(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_tree_state_push(arg1: *mut nk_context, arg2: nk_tree_type,
                              title: *const ::std::os::raw::c_char,
                              state: *mut nk_collapse_states)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_tree_state_image_push(arg1: *mut nk_context, arg2: nk_tree_type,
                                    arg3: nk_image,
                                    title: *const ::std::os::raw::c_char,
                                    state: *mut nk_collapse_states)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_tree_state_pop(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_text(arg1: *mut nk_context, arg2: *const ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int, arg4: nk_flags);
}
extern "C" {
    pub fn nk_text_colored(arg1: *mut nk_context,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: ::std::os::raw::c_int, arg4: nk_flags,
                           arg5: nk_color);
}
extern "C" {
    pub fn nk_text_wrap(arg1: *mut nk_context,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_text_wrap_colored(arg1: *mut nk_context,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: ::std::os::raw::c_int, arg4: nk_color);
}
extern "C" {
    pub fn nk_label(arg1: *mut nk_context,
                    arg2: *const ::std::os::raw::c_char, align: nk_flags);
}
extern "C" {
    pub fn nk_label_colored(arg1: *mut nk_context,
                            arg2: *const ::std::os::raw::c_char,
                            align: nk_flags, arg3: nk_color);
}
extern "C" {
    pub fn nk_label_wrap(arg1: *mut nk_context,
                         arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nk_label_colored_wrap(arg1: *mut nk_context,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: nk_color);
}
extern "C" {
    pub fn nk_image(arg1: *mut nk_context, arg2: nk_image);
}
extern "C" {
    pub fn nk_button_set_behavior(arg1: *mut nk_context,
                                  arg2: nk_button_behavior);
}
extern "C" {
    pub fn nk_button_push_behavior(arg1: *mut nk_context,
                                   arg2: nk_button_behavior)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_pop_behavior(arg1: *mut nk_context)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_text(arg1: *mut nk_context,
                          title: *const ::std::os::raw::c_char,
                          len: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_label(arg1: *mut nk_context,
                           title: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_color(arg1: *mut nk_context, arg2: nk_color)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_symbol(arg1: *mut nk_context, arg2: nk_symbol_type)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_image(arg1: *mut nk_context, img: nk_image)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_symbol_label(arg1: *mut nk_context, arg2: nk_symbol_type,
                                  arg3: *const ::std::os::raw::c_char,
                                  text_alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_symbol_text(arg1: *mut nk_context, arg2: nk_symbol_type,
                                 arg3: *const ::std::os::raw::c_char,
                                 arg4: ::std::os::raw::c_int,
                                 alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_image_label(arg1: *mut nk_context, img: nk_image,
                                 arg2: *const ::std::os::raw::c_char,
                                 text_alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_image_text(arg1: *mut nk_context, img: nk_image,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: ::std::os::raw::c_int,
                                alignment: nk_flags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_text_styled(arg1: *mut nk_context,
                                 arg2: *const nk_style_button,
                                 title: *const ::std::os::raw::c_char,
                                 len: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_label_styled(arg1: *mut nk_context,
                                  arg2: *const nk_style_button,
                                  title: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_symbol_styled(arg1: *mut nk_context,
                                   arg2: *const nk_style_button,
                                   arg3: nk_symbol_type)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_image_styled(arg1: *mut nk_context,
                                  arg2: *const nk_style_button, img: nk_image)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_symbol_label_styled(arg1: *mut nk_context,
                                         arg2: *const nk_style_button,
                                         arg3: nk_symbol_type,
                                         arg4: *const ::std::os::raw::c_char,
                                         text_alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_symbol_text_styled(arg1: *mut nk_context,
                                        arg2: *const nk_style_button,
                                        arg3: nk_symbol_type,
                                        arg4: *const ::std::os::raw::c_char,
                                        arg5: ::std::os::raw::c_int,
                                        alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_image_label_styled(arg1: *mut nk_context,
                                        arg2: *const nk_style_button,
                                        img: nk_image,
                                        arg3: *const ::std::os::raw::c_char,
                                        text_alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_button_image_text_styled(arg1: *mut nk_context,
                                       arg2: *const nk_style_button,
                                       img: nk_image,
                                       arg3: *const ::std::os::raw::c_char,
                                       arg4: ::std::os::raw::c_int,
                                       alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_check_label(arg1: *mut nk_context,
                          arg2: *const ::std::os::raw::c_char,
                          active: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_check_text(arg1: *mut nk_context,
                         arg2: *const ::std::os::raw::c_char,
                         arg3: ::std::os::raw::c_int,
                         active: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_check_flags_label(arg1: *mut nk_context,
                                arg2: *const ::std::os::raw::c_char,
                                flags: ::std::os::raw::c_uint,
                                value: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn nk_check_flags_text(arg1: *mut nk_context,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: ::std::os::raw::c_int,
                               flags: ::std::os::raw::c_uint,
                               value: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn nk_checkbox_label(arg1: *mut nk_context,
                             arg2: *const ::std::os::raw::c_char,
                             active: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_checkbox_text(arg1: *mut nk_context,
                            arg2: *const ::std::os::raw::c_char,
                            arg3: ::std::os::raw::c_int,
                            active: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_checkbox_flags_label(arg1: *mut nk_context,
                                   arg2: *const ::std::os::raw::c_char,
                                   flags: *mut ::std::os::raw::c_uint,
                                   value: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_checkbox_flags_text(arg1: *mut nk_context,
                                  arg2: *const ::std::os::raw::c_char,
                                  arg3: ::std::os::raw::c_int,
                                  flags: *mut ::std::os::raw::c_uint,
                                  value: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_radio_label(arg1: *mut nk_context,
                          arg2: *const ::std::os::raw::c_char,
                          active: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_radio_text(arg1: *mut nk_context,
                         arg2: *const ::std::os::raw::c_char,
                         arg3: ::std::os::raw::c_int,
                         active: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_option_label(arg1: *mut nk_context,
                           arg2: *const ::std::os::raw::c_char,
                           active: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_option_text(arg1: *mut nk_context,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_int,
                          active: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_selectable_label(arg1: *mut nk_context,
                               arg2: *const ::std::os::raw::c_char,
                               align: nk_flags,
                               value: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_selectable_text(arg1: *mut nk_context,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: ::std::os::raw::c_int, align: nk_flags,
                              value: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_selectable_image_label(arg1: *mut nk_context, arg2: nk_image,
                                     arg3: *const ::std::os::raw::c_char,
                                     align: nk_flags,
                                     value: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_selectable_image_text(arg1: *mut nk_context, arg2: nk_image,
                                    arg3: *const ::std::os::raw::c_char,
                                    arg4: ::std::os::raw::c_int,
                                    align: nk_flags,
                                    value: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_select_label(arg1: *mut nk_context,
                           arg2: *const ::std::os::raw::c_char,
                           align: nk_flags, value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_select_text(arg1: *mut nk_context,
                          arg2: *const ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_int, align: nk_flags,
                          value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_select_image_label(arg1: *mut nk_context, arg2: nk_image,
                                 arg3: *const ::std::os::raw::c_char,
                                 align: nk_flags,
                                 value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_select_image_text(arg1: *mut nk_context, arg2: nk_image,
                                arg3: *const ::std::os::raw::c_char,
                                arg4: ::std::os::raw::c_int, align: nk_flags,
                                value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_slide_float(arg1: *mut nk_context, min: f32, val: f32, max: f32,
                          step: f32) -> f32;
}
extern "C" {
    pub fn nk_slide_int(arg1: *mut nk_context, min: ::std::os::raw::c_int,
                        val: ::std::os::raw::c_int,
                        max: ::std::os::raw::c_int,
                        step: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_slider_float(arg1: *mut nk_context, min: f32, val: *mut f32,
                           max: f32, step: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_slider_int(arg1: *mut nk_context, min: ::std::os::raw::c_int,
                         val: *mut ::std::os::raw::c_int,
                         max: ::std::os::raw::c_int,
                         step: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_progress(arg1: *mut nk_context, cur: *mut nk_size, max: nk_size,
                       modifyable: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_prog(arg1: *mut nk_context, cur: nk_size, max: nk_size,
                   modifyable: ::std::os::raw::c_int) -> nk_size;
}
extern "C" {
    pub fn nk_color_picker(arg1: *mut nk_context, arg2: nk_color,
                           arg3: nk_color_format) -> nk_color;
}
extern "C" {
    pub fn nk_color_pick(arg1: *mut nk_context, arg2: *mut nk_color,
                         arg3: nk_color_format) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_property_int(arg1: *mut nk_context,
                           name: *const ::std::os::raw::c_char,
                           min: ::std::os::raw::c_int,
                           val: *mut ::std::os::raw::c_int,
                           max: ::std::os::raw::c_int,
                           step: ::std::os::raw::c_int, inc_per_pixel: f32);
}
extern "C" {
    pub fn nk_property_float(arg1: *mut nk_context,
                             name: *const ::std::os::raw::c_char, min: f32,
                             val: *mut f32, max: f32, step: f32,
                             inc_per_pixel: f32);
}
extern "C" {
    pub fn nk_property_double(arg1: *mut nk_context,
                              name: *const ::std::os::raw::c_char, min: f64,
                              val: *mut f64, max: f64, step: f64,
                              inc_per_pixel: f32);
}
extern "C" {
    pub fn nk_propertyi(arg1: *mut nk_context,
                        name: *const ::std::os::raw::c_char,
                        min: ::std::os::raw::c_int,
                        val: ::std::os::raw::c_int,
                        max: ::std::os::raw::c_int,
                        step: ::std::os::raw::c_int, inc_per_pixel: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_propertyf(arg1: *mut nk_context,
                        name: *const ::std::os::raw::c_char, min: f32,
                        val: f32, max: f32, step: f32, inc_per_pixel: f32)
     -> f32;
}
extern "C" {
    pub fn nk_propertyd(arg1: *mut nk_context,
                        name: *const ::std::os::raw::c_char, min: f64,
                        val: f64, max: f64, step: f64, inc_per_pixel: f32)
     -> f64;
}
extern "C" {
    pub fn nk_edit_focus(arg1: *mut nk_context, flags: nk_flags);
}
extern "C" {
    pub fn nk_edit_unfocus(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_edit_string(arg1: *mut nk_context, arg2: nk_flags,
                          buffer: *mut ::std::os::raw::c_char,
                          len: *mut ::std::os::raw::c_int,
                          max: ::std::os::raw::c_int, arg3: nk_plugin_filter)
     -> nk_flags;
}
extern "C" {
    pub fn nk_edit_buffer(arg1: *mut nk_context, arg2: nk_flags,
                          arg3: *mut nk_text_edit, arg4: nk_plugin_filter)
     -> nk_flags;
}
extern "C" {
    pub fn nk_edit_string_zero_terminated(arg1: *mut nk_context,
                                          arg2: nk_flags,
                                          buffer: *mut ::std::os::raw::c_char,
                                          max: ::std::os::raw::c_int,
                                          arg3: nk_plugin_filter) -> nk_flags;
}
extern "C" {
    pub fn nk_chart_begin(arg1: *mut nk_context, arg2: nk_chart_type,
                          num: ::std::os::raw::c_int, min: f32, max: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_chart_begin_colored(arg1: *mut nk_context, arg2: nk_chart_type,
                                  arg3: nk_color, active: nk_color,
                                  num: ::std::os::raw::c_int, min: f32,
                                  max: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_chart_add_slot(ctx: *mut nk_context, arg1: nk_chart_type,
                             count: ::std::os::raw::c_int, min_value: f32,
                             max_value: f32);
}
extern "C" {
    pub fn nk_chart_add_slot_colored(ctx: *mut nk_context,
                                     arg1: nk_chart_type, arg2: nk_color,
                                     active: nk_color,
                                     count: ::std::os::raw::c_int,
                                     min_value: f32, max_value: f32);
}
extern "C" {
    pub fn nk_chart_push(arg1: *mut nk_context, arg2: f32) -> nk_flags;
}
extern "C" {
    pub fn nk_chart_push_slot(arg1: *mut nk_context, arg2: f32,
                              arg3: ::std::os::raw::c_int) -> nk_flags;
}
extern "C" {
    pub fn nk_chart_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_plot(arg1: *mut nk_context, arg2: nk_chart_type,
                   values: *const f32, count: ::std::os::raw::c_int,
                   offset: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_plot_function(arg1: *mut nk_context, arg2: nk_chart_type,
                            userdata: *mut ::std::os::raw::c_void,
                            value_getter:
                                ::std::option::Option<unsafe extern "C" fn(user:
                                                                               *mut ::std::os::raw::c_void,
                                                                           index:
                                                                               ::std::os::raw::c_int)
                                                          -> f32>,
                            count: ::std::os::raw::c_int,
                            offset: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_popup_begin(arg1: *mut nk_context, arg2: nk_popup_type,
                          arg3: *const ::std::os::raw::c_char, arg4: nk_flags,
                          bounds: nk_rect) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_popup_close(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_popup_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_combo(arg1: *mut nk_context,
                    items: *mut *const ::std::os::raw::c_char,
                    count: ::std::os::raw::c_int,
                    selected: ::std::os::raw::c_int,
                    item_height: ::std::os::raw::c_int, size: nk_vec2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_separator(arg1: *mut nk_context,
                              items_separated_by_separator:
                                  *const ::std::os::raw::c_char,
                              separator: ::std::os::raw::c_int,
                              selected: ::std::os::raw::c_int,
                              count: ::std::os::raw::c_int,
                              item_height: ::std::os::raw::c_int,
                              size: nk_vec2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_string(arg1: *mut nk_context,
                           items_separated_by_zeros:
                               *const ::std::os::raw::c_char,
                           selected: ::std::os::raw::c_int,
                           count: ::std::os::raw::c_int,
                           item_height: ::std::os::raw::c_int, size: nk_vec2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_callback(arg1: *mut nk_context,
                             item_getter:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut ::std::os::raw::c_void,
                                                                            arg2:
                                                                                ::std::os::raw::c_int,
                                                                            arg3:
                                                                                *mut *const ::std::os::raw::c_char)>,
                             userdata: *mut ::std::os::raw::c_void,
                             selected: ::std::os::raw::c_int,
                             count: ::std::os::raw::c_int,
                             item_height: ::std::os::raw::c_int,
                             size: nk_vec2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combobox(arg1: *mut nk_context,
                       items: *mut *const ::std::os::raw::c_char,
                       count: ::std::os::raw::c_int,
                       selected: *mut ::std::os::raw::c_int,
                       item_height: ::std::os::raw::c_int, size: nk_vec2);
}
extern "C" {
    pub fn nk_combobox_string(arg1: *mut nk_context,
                              items_separated_by_zeros:
                                  *const ::std::os::raw::c_char,
                              selected: *mut ::std::os::raw::c_int,
                              count: ::std::os::raw::c_int,
                              item_height: ::std::os::raw::c_int,
                              size: nk_vec2);
}
extern "C" {
    pub fn nk_combobox_separator(arg1: *mut nk_context,
                                 items_separated_by_separator:
                                     *const ::std::os::raw::c_char,
                                 separator: ::std::os::raw::c_int,
                                 selected: *mut ::std::os::raw::c_int,
                                 count: ::std::os::raw::c_int,
                                 item_height: ::std::os::raw::c_int,
                                 size: nk_vec2);
}
extern "C" {
    pub fn nk_combobox_callback(arg1: *mut nk_context,
                                item_getter:
                                    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                   *mut ::std::os::raw::c_void,
                                                                               arg2:
                                                                                   ::std::os::raw::c_int,
                                                                               arg3:
                                                                                   *mut *const ::std::os::raw::c_char)>,
                                arg2: *mut ::std::os::raw::c_void,
                                selected: *mut ::std::os::raw::c_int,
                                count: ::std::os::raw::c_int,
                                item_height: ::std::os::raw::c_int,
                                size: nk_vec2);
}
extern "C" {
    pub fn nk_combo_begin_text(arg1: *mut nk_context,
                               selected: *const ::std::os::raw::c_char,
                               arg2: ::std::os::raw::c_int, size: nk_vec2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_begin_label(arg1: *mut nk_context,
                                selected: *const ::std::os::raw::c_char,
                                size: nk_vec2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_begin_color(arg1: *mut nk_context, color: nk_color,
                                size: nk_vec2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_begin_symbol(arg1: *mut nk_context, arg2: nk_symbol_type,
                                 size: nk_vec2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_begin_symbol_label(arg1: *mut nk_context,
                                       selected:
                                           *const ::std::os::raw::c_char,
                                       arg2: nk_symbol_type, size: nk_vec2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_begin_symbol_text(arg1: *mut nk_context,
                                      selected: *const ::std::os::raw::c_char,
                                      arg2: ::std::os::raw::c_int,
                                      arg3: nk_symbol_type, size: nk_vec2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_begin_image(arg1: *mut nk_context, img: nk_image,
                                size: nk_vec2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_begin_image_label(arg1: *mut nk_context,
                                      selected: *const ::std::os::raw::c_char,
                                      arg2: nk_image, size: nk_vec2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_begin_image_text(arg1: *mut nk_context,
                                     selected: *const ::std::os::raw::c_char,
                                     arg2: ::std::os::raw::c_int,
                                     arg3: nk_image, size: nk_vec2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_item_label(arg1: *mut nk_context,
                               arg2: *const ::std::os::raw::c_char,
                               alignment: nk_flags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_item_text(arg1: *mut nk_context,
                              arg2: *const ::std::os::raw::c_char,
                              arg3: ::std::os::raw::c_int,
                              alignment: nk_flags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_item_image_label(arg1: *mut nk_context, arg2: nk_image,
                                     arg3: *const ::std::os::raw::c_char,
                                     alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_item_image_text(arg1: *mut nk_context, arg2: nk_image,
                                    arg3: *const ::std::os::raw::c_char,
                                    arg4: ::std::os::raw::c_int,
                                    alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_item_symbol_label(arg1: *mut nk_context,
                                      arg2: nk_symbol_type,
                                      arg3: *const ::std::os::raw::c_char,
                                      alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_item_symbol_text(arg1: *mut nk_context,
                                     arg2: nk_symbol_type,
                                     arg3: *const ::std::os::raw::c_char,
                                     arg4: ::std::os::raw::c_int,
                                     alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_combo_close(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_combo_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_contextual_begin(arg1: *mut nk_context, arg2: nk_flags,
                               arg3: nk_vec2, trigger_bounds: nk_rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_contextual_item_text(arg1: *mut nk_context,
                                   arg2: *const ::std::os::raw::c_char,
                                   arg3: ::std::os::raw::c_int,
                                   align: nk_flags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_contextual_item_label(arg1: *mut nk_context,
                                    arg2: *const ::std::os::raw::c_char,
                                    align: nk_flags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_contextual_item_image_label(arg1: *mut nk_context,
                                          arg2: nk_image,
                                          arg3: *const ::std::os::raw::c_char,
                                          alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_contextual_item_image_text(arg1: *mut nk_context,
                                         arg2: nk_image,
                                         arg3: *const ::std::os::raw::c_char,
                                         len: ::std::os::raw::c_int,
                                         alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_contextual_item_symbol_label(arg1: *mut nk_context,
                                           arg2: nk_symbol_type,
                                           arg3:
                                               *const ::std::os::raw::c_char,
                                           alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_contextual_item_symbol_text(arg1: *mut nk_context,
                                          arg2: nk_symbol_type,
                                          arg3: *const ::std::os::raw::c_char,
                                          arg4: ::std::os::raw::c_int,
                                          alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_contextual_close(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_contextual_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_tooltip(arg1: *mut nk_context,
                      arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nk_tooltip_begin(arg1: *mut nk_context, width: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_tooltip_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_menubar_begin(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_menubar_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_menu_begin_text(arg1: *mut nk_context,
                              title: *const ::std::os::raw::c_char,
                              title_len: ::std::os::raw::c_int,
                              align: nk_flags, size: nk_vec2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_begin_label(arg1: *mut nk_context,
                               arg2: *const ::std::os::raw::c_char,
                               align: nk_flags, size: nk_vec2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_begin_image(arg1: *mut nk_context,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: nk_image, size: nk_vec2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_begin_image_text(arg1: *mut nk_context,
                                    arg2: *const ::std::os::raw::c_char,
                                    arg3: ::std::os::raw::c_int,
                                    align: nk_flags, arg4: nk_image,
                                    size: nk_vec2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_begin_image_label(arg1: *mut nk_context,
                                     arg2: *const ::std::os::raw::c_char,
                                     align: nk_flags, arg3: nk_image,
                                     size: nk_vec2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_begin_symbol(arg1: *mut nk_context,
                                arg2: *const ::std::os::raw::c_char,
                                arg3: nk_symbol_type, size: nk_vec2)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_begin_symbol_text(arg1: *mut nk_context,
                                     arg2: *const ::std::os::raw::c_char,
                                     arg3: ::std::os::raw::c_int,
                                     align: nk_flags, arg4: nk_symbol_type,
                                     size: nk_vec2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_begin_symbol_label(arg1: *mut nk_context,
                                      arg2: *const ::std::os::raw::c_char,
                                      align: nk_flags, arg3: nk_symbol_type,
                                      size: nk_vec2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_item_text(arg1: *mut nk_context,
                             arg2: *const ::std::os::raw::c_char,
                             arg3: ::std::os::raw::c_int, align: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_item_label(arg1: *mut nk_context,
                              arg2: *const ::std::os::raw::c_char,
                              alignment: nk_flags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_item_image_label(arg1: *mut nk_context, arg2: nk_image,
                                    arg3: *const ::std::os::raw::c_char,
                                    alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_item_image_text(arg1: *mut nk_context, arg2: nk_image,
                                   arg3: *const ::std::os::raw::c_char,
                                   len: ::std::os::raw::c_int,
                                   alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_item_symbol_text(arg1: *mut nk_context,
                                    arg2: nk_symbol_type,
                                    arg3: *const ::std::os::raw::c_char,
                                    arg4: ::std::os::raw::c_int,
                                    alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_item_symbol_label(arg1: *mut nk_context,
                                     arg2: nk_symbol_type,
                                     arg3: *const ::std::os::raw::c_char,
                                     alignment: nk_flags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_menu_close(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_menu_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_convert(arg1: *mut nk_context, cmds: *mut nk_buffer,
                      vertices: *mut nk_buffer, elements: *mut nk_buffer,
                      arg2: *const nk_convert_config);
}
extern "C" {
    pub fn nk__draw_begin(arg1: *const nk_context, arg2: *const nk_buffer)
     -> *const nk_draw_command;
}
extern "C" {
    pub fn nk__draw_end(arg1: *const nk_context, arg2: *const nk_buffer)
     -> *const nk_draw_command;
}
extern "C" {
    pub fn nk__draw_next(arg1: *const nk_draw_command, arg2: *const nk_buffer,
                         arg3: *const nk_context) -> *const nk_draw_command;
}
extern "C" {
    pub fn nk_input_begin(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_input_motion(arg1: *mut nk_context, x: ::std::os::raw::c_int,
                           y: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_input_key(arg1: *mut nk_context, arg2: nk_keys,
                        down: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_input_button(arg1: *mut nk_context, arg2: nk_buttons,
                           x: ::std::os::raw::c_int, y: ::std::os::raw::c_int,
                           down: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_input_scroll(arg1: *mut nk_context, y: f32);
}
extern "C" {
    pub fn nk_input_char(arg1: *mut nk_context, arg2: ::std::os::raw::c_char);
}
extern "C" {
    pub fn nk_input_glyph(arg1: *mut nk_context,
                          arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn nk_input_unicode(arg1: *mut nk_context, arg2: nk_rune);
}
extern "C" {
    pub fn nk_input_end(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_style_default(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_style_from_table(arg1: *mut nk_context, arg2: *const nk_color);
}
extern "C" {
    pub fn nk_style_load_cursor(arg1: *mut nk_context, arg2: nk_style_cursor,
                                arg3: *const nk_cursor);
}
extern "C" {
    pub fn nk_style_load_all_cursors(arg1: *mut nk_context,
                                     arg2: *mut nk_cursor);
}
extern "C" {
    pub fn nk_style_get_color_by_name(arg1: nk_style_colors)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nk_style_set_font(arg1: *mut nk_context,
                             arg2: *const nk_user_font);
}
extern "C" {
    pub fn nk_style_set_cursor(arg1: *mut nk_context, arg2: nk_style_cursor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_show_cursor(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_style_hide_cursor(arg1: *mut nk_context);
}
extern "C" {
    pub fn nk_style_push_font(arg1: *mut nk_context, arg2: *mut nk_user_font)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_push_float(arg1: *mut nk_context, arg2: *mut f32,
                               arg3: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_push_vec2(arg1: *mut nk_context, arg2: *mut nk_vec2,
                              arg3: nk_vec2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_push_style_item(arg1: *mut nk_context,
                                    arg2: *mut nk_style_item,
                                    arg3: nk_style_item)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_push_flags(arg1: *mut nk_context, arg2: *mut nk_flags,
                               arg3: nk_flags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_push_color(arg1: *mut nk_context, arg2: *mut nk_color,
                               arg3: nk_color) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_pop_font(arg1: *mut nk_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_pop_float(arg1: *mut nk_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_pop_vec2(arg1: *mut nk_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_pop_style_item(arg1: *mut nk_context)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_pop_flags(arg1: *mut nk_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_style_pop_color(arg1: *mut nk_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_widget_bounds(arg1: *mut nk_context) -> nk_rect;
}
extern "C" {
    pub fn nk_widget_position(arg1: *mut nk_context) -> nk_vec2;
}
extern "C" {
    pub fn nk_widget_size(arg1: *mut nk_context) -> nk_vec2;
}
extern "C" {
    pub fn nk_widget_width(arg1: *mut nk_context) -> f32;
}
extern "C" {
    pub fn nk_widget_height(arg1: *mut nk_context) -> f32;
}
extern "C" {
    pub fn nk_widget_is_hovered(arg1: *mut nk_context)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_widget_is_mouse_clicked(arg1: *mut nk_context, arg2: nk_buttons)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_widget_has_mouse_click_down(arg1: *mut nk_context,
                                          arg2: nk_buttons,
                                          down: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_spacing(arg1: *mut nk_context, cols: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_widget(arg1: *mut nk_rect, arg2: *const nk_context)
     -> nk_widget_layout_states;
}
extern "C" {
    pub fn nk_widget_fitting(arg1: *mut nk_rect, arg2: *mut nk_context,
                             arg3: nk_vec2) -> nk_widget_layout_states;
}
extern "C" {
    pub fn nk_rgb(r: ::std::os::raw::c_int, g: ::std::os::raw::c_int,
                  b: ::std::os::raw::c_int) -> nk_color;
}
extern "C" {
    pub fn nk_rgb_iv(rgb: *const ::std::os::raw::c_int) -> nk_color;
}
extern "C" {
    pub fn nk_rgb_bv(rgb: *const nk_byte) -> nk_color;
}
extern "C" {
    pub fn nk_rgb_f(r: f32, g: f32, b: f32) -> nk_color;
}
extern "C" {
    pub fn nk_rgb_fv(rgb: *const f32) -> nk_color;
}
extern "C" {
    pub fn nk_rgb_hex(rgb: *const ::std::os::raw::c_char) -> nk_color;
}
extern "C" {
    pub fn nk_rgba(r: ::std::os::raw::c_int, g: ::std::os::raw::c_int,
                   b: ::std::os::raw::c_int, a: ::std::os::raw::c_int)
     -> nk_color;
}
extern "C" {
    pub fn nk_rgba_u32(arg1: nk_uint) -> nk_color;
}
extern "C" {
    pub fn nk_rgba_iv(rgba: *const ::std::os::raw::c_int) -> nk_color;
}
extern "C" {
    pub fn nk_rgba_bv(rgba: *const nk_byte) -> nk_color;
}
extern "C" {
    pub fn nk_rgba_f(r: f32, g: f32, b: f32, a: f32) -> nk_color;
}
extern "C" {
    pub fn nk_rgba_fv(rgba: *const f32) -> nk_color;
}
extern "C" {
    pub fn nk_rgba_hex(rgb: *const ::std::os::raw::c_char) -> nk_color;
}
extern "C" {
    pub fn nk_hsv(h: ::std::os::raw::c_int, s: ::std::os::raw::c_int,
                  v: ::std::os::raw::c_int) -> nk_color;
}
extern "C" {
    pub fn nk_hsv_iv(hsv: *const ::std::os::raw::c_int) -> nk_color;
}
extern "C" {
    pub fn nk_hsv_bv(hsv: *const nk_byte) -> nk_color;
}
extern "C" {
    pub fn nk_hsv_f(h: f32, s: f32, v: f32) -> nk_color;
}
extern "C" {
    pub fn nk_hsv_fv(hsv: *const f32) -> nk_color;
}
extern "C" {
    pub fn nk_hsva(h: ::std::os::raw::c_int, s: ::std::os::raw::c_int,
                   v: ::std::os::raw::c_int, a: ::std::os::raw::c_int)
     -> nk_color;
}
extern "C" {
    pub fn nk_hsva_iv(hsva: *const ::std::os::raw::c_int) -> nk_color;
}
extern "C" {
    pub fn nk_hsva_bv(hsva: *const nk_byte) -> nk_color;
}
extern "C" {
    pub fn nk_hsva_f(h: f32, s: f32, v: f32, a: f32) -> nk_color;
}
extern "C" {
    pub fn nk_hsva_fv(hsva: *const f32) -> nk_color;
}
extern "C" {
    pub fn nk_color_f(r: *mut f32, g: *mut f32, b: *mut f32, a: *mut f32,
                      arg1: nk_color);
}
extern "C" {
    pub fn nk_color_fv(rgba_out: *mut f32, arg1: nk_color);
}
extern "C" {
    pub fn nk_color_d(r: *mut f64, g: *mut f64, b: *mut f64, a: *mut f64,
                      arg1: nk_color);
}
extern "C" {
    pub fn nk_color_dv(rgba_out: *mut f64, arg1: nk_color);
}
extern "C" {
    pub fn nk_color_u32(arg1: nk_color) -> nk_uint;
}
extern "C" {
    pub fn nk_color_hex_rgba(output: *mut ::std::os::raw::c_char,
                             arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hex_rgb(output: *mut ::std::os::raw::c_char,
                            arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsv_i(out_h: *mut ::std::os::raw::c_int,
                          out_s: *mut ::std::os::raw::c_int,
                          out_v: *mut ::std::os::raw::c_int, arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsv_b(out_h: *mut nk_byte, out_s: *mut nk_byte,
                          out_v: *mut nk_byte, arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsv_iv(hsv_out: *mut ::std::os::raw::c_int,
                           arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsv_bv(hsv_out: *mut nk_byte, arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsv_f(out_h: *mut f32, out_s: *mut f32, out_v: *mut f32,
                          arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsv_fv(hsv_out: *mut f32, arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsva_i(h: *mut ::std::os::raw::c_int,
                           s: *mut ::std::os::raw::c_int,
                           v: *mut ::std::os::raw::c_int,
                           a: *mut ::std::os::raw::c_int, arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsva_b(h: *mut nk_byte, s: *mut nk_byte, v: *mut nk_byte,
                           a: *mut nk_byte, arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsva_iv(hsva_out: *mut ::std::os::raw::c_int,
                            arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsva_bv(hsva_out: *mut nk_byte, arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsva_f(out_h: *mut f32, out_s: *mut f32, out_v: *mut f32,
                           out_a: *mut f32, arg1: nk_color);
}
extern "C" {
    pub fn nk_color_hsva_fv(hsva_out: *mut f32, arg1: nk_color);
}
extern "C" {
    pub fn nk_handle_ptr(arg1: *mut ::std::os::raw::c_void) -> nk_handle;
}
extern "C" {
    pub fn nk_handle_id(arg1: ::std::os::raw::c_int) -> nk_handle;
}
extern "C" {
    pub fn nk_image_handle(arg1: nk_handle) -> nk_image;
}
extern "C" {
    pub fn nk_image_ptr(arg1: *mut ::std::os::raw::c_void) -> nk_image;
}
extern "C" {
    pub fn nk_image_id(arg1: ::std::os::raw::c_int) -> nk_image;
}
extern "C" {
    pub fn nk_image_is_subimage(img: *const nk_image)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_subimage_ptr(arg1: *mut ::std::os::raw::c_void,
                           w: ::std::os::raw::c_ushort,
                           h: ::std::os::raw::c_ushort, sub_region: nk_rect)
     -> nk_image;
}
extern "C" {
    pub fn nk_subimage_id(arg1: ::std::os::raw::c_int,
                          w: ::std::os::raw::c_ushort,
                          h: ::std::os::raw::c_ushort, sub_region: nk_rect)
     -> nk_image;
}
extern "C" {
    pub fn nk_subimage_handle(arg1: nk_handle, w: ::std::os::raw::c_ushort,
                              h: ::std::os::raw::c_ushort,
                              sub_region: nk_rect) -> nk_image;
}
extern "C" {
    pub fn nk_murmur_hash(key: *const ::std::os::raw::c_void,
                          len: ::std::os::raw::c_int, seed: nk_hash)
     -> nk_hash;
}
extern "C" {
    pub fn nk_triangle_from_direction(result: *mut nk_vec2, r: nk_rect,
                                      pad_x: f32, pad_y: f32,
                                      arg1: nk_heading);
}
extern "C" {
    pub fn nk_vec2(x: f32, y: f32) -> nk_vec2;
}
extern "C" {
    pub fn nk_vec2i(x: ::std::os::raw::c_int, y: ::std::os::raw::c_int)
     -> nk_vec2;
}
extern "C" {
    pub fn nk_vec2v(xy: *const f32) -> nk_vec2;
}
extern "C" {
    pub fn nk_vec2iv(xy: *const ::std::os::raw::c_int) -> nk_vec2;
}
extern "C" {
    pub fn nk_get_null_rect() -> nk_rect;
}
extern "C" {
    pub fn nk_rect(x: f32, y: f32, w: f32, h: f32) -> nk_rect;
}
extern "C" {
    pub fn nk_recti(x: ::std::os::raw::c_int, y: ::std::os::raw::c_int,
                    w: ::std::os::raw::c_int, h: ::std::os::raw::c_int)
     -> nk_rect;
}
extern "C" {
    pub fn nk_recta(pos: nk_vec2, size: nk_vec2) -> nk_rect;
}
extern "C" {
    pub fn nk_rectv(xywh: *const f32) -> nk_rect;
}
extern "C" {
    pub fn nk_rectiv(xywh: *const ::std::os::raw::c_int) -> nk_rect;
}
extern "C" {
    pub fn nk_rect_pos(arg1: nk_rect) -> nk_vec2;
}
extern "C" {
    pub fn nk_rect_size(arg1: nk_rect) -> nk_vec2;
}
extern "C" {
    pub fn nk_strlen(str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_stricmp(s1: *const ::std::os::raw::c_char,
                      s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_stricmpn(s1: *const ::std::os::raw::c_char,
                       s2: *const ::std::os::raw::c_char,
                       n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_strtoi(str: *const ::std::os::raw::c_char,
                     endptr: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_strtof(str: *const ::std::os::raw::c_char,
                     endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nk_strtod(str: *const ::std::os::raw::c_char,
                     endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nk_strfilter(text: *const ::std::os::raw::c_char,
                        regexp: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_strmatch_fuzzy_string(str: *const ::std::os::raw::c_char,
                                    pattern: *const ::std::os::raw::c_char,
                                    out_score: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_strmatch_fuzzy_text(txt: *const ::std::os::raw::c_char,
                                  txt_len: ::std::os::raw::c_int,
                                  pattern: *const ::std::os::raw::c_char,
                                  out_score: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_utf_decode(arg1: *const ::std::os::raw::c_char,
                         arg2: *mut nk_rune, arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_utf_encode(arg1: nk_rune, arg2: *mut ::std::os::raw::c_char,
                         arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_utf_len(arg1: *const ::std::os::raw::c_char,
                      byte_len: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_utf_at(buffer: *const ::std::os::raw::c_char,
                     length: ::std::os::raw::c_int,
                     index: ::std::os::raw::c_int, unicode: *mut nk_rune,
                     len: *mut ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_user_font_glyph {
    pub uv: [nk_vec2; 2usize],
    pub offset: nk_vec2,
    pub width: f32,
    pub height: f32,
    pub xadvance: f32,
}
#[test]
fn bindgen_test_layout_nk_user_font_glyph() {
    assert_eq!(::std::mem::size_of::<nk_user_font_glyph>() , 36usize , concat
               ! ( "Size of: " , stringify ! ( nk_user_font_glyph ) ));
    assert_eq! (::std::mem::align_of::<nk_user_font_glyph>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( nk_user_font_glyph ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_user_font_glyph ) ) . uv as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_user_font_glyph ) ,
                "::" , stringify ! ( uv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_user_font_glyph ) ) . offset as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_user_font_glyph ) ,
                "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_user_font_glyph ) ) . width as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_user_font_glyph ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_user_font_glyph ) ) . height as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_user_font_glyph ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_user_font_glyph ) ) . xadvance as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_user_font_glyph ) ,
                "::" , stringify ! ( xadvance ) ));
}
impl Clone for nk_user_font_glyph {
    fn clone(&self) -> Self { *self }
}
pub type nk_text_width_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: nk_handle, h: f32,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               len: ::std::os::raw::c_int)
                              -> f32>;
pub type nk_query_font_glyph_f =
    ::std::option::Option<unsafe extern "C" fn(handle: nk_handle,
                                               font_height: f32,
                                               glyph: *mut nk_user_font_glyph,
                                               codepoint: nk_rune,
                                               next_codepoint: nk_rune)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_font_coord_type { NK_COORD_UV = 0, NK_COORD_PIXEL = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_baked_font {
    pub height: f32,
    pub ascent: f32,
    pub descent: f32,
    pub glyph_offset: nk_rune,
    pub glyph_count: nk_rune,
    pub ranges: *const nk_rune,
}
#[test]
fn bindgen_test_layout_nk_baked_font() {
    assert_eq!(::std::mem::size_of::<nk_baked_font>() , 32usize , concat ! (
               "Size of: " , stringify ! ( nk_baked_font ) ));
    assert_eq! (::std::mem::align_of::<nk_baked_font>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_baked_font ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_baked_font ) ) . height as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_baked_font ) , "::"
                , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_baked_font ) ) . ascent as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_baked_font ) , "::"
                , stringify ! ( ascent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_baked_font ) ) . descent as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_baked_font ) , "::"
                , stringify ! ( descent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_baked_font ) ) . glyph_offset as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_baked_font ) , "::"
                , stringify ! ( glyph_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_baked_font ) ) . glyph_count as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_baked_font ) , "::"
                , stringify ! ( glyph_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_baked_font ) ) . ranges as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_baked_font ) , "::"
                , stringify ! ( ranges ) ));
}
impl Clone for nk_baked_font {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_baked_font {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_font_config {
    pub next: *mut nk_font_config,
    pub ttf_blob: *mut ::std::os::raw::c_void,
    pub ttf_size: nk_size,
    pub ttf_data_owned_by_atlas: ::std::os::raw::c_uchar,
    pub merge_mode: ::std::os::raw::c_uchar,
    pub pixel_snap: ::std::os::raw::c_uchar,
    pub oversample_v: ::std::os::raw::c_uchar,
    pub oversample_h: ::std::os::raw::c_uchar,
    pub padding: [::std::os::raw::c_uchar; 3usize],
    pub size: f32,
    pub coord_type: nk_font_coord_type,
    pub spacing: nk_vec2,
    pub range: *const nk_rune,
    pub font: *mut nk_baked_font,
    pub fallback_glyph: nk_rune,
}
#[test]
fn bindgen_test_layout_nk_font_config() {
    assert_eq!(::std::mem::size_of::<nk_font_config>() , 72usize , concat ! (
               "Size of: " , stringify ! ( nk_font_config ) ));
    assert_eq! (::std::mem::align_of::<nk_font_config>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_font_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . ttf_blob as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( ttf_blob ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . ttf_size as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( ttf_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) .
                ttf_data_owned_by_atlas as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( ttf_data_owned_by_atlas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . merge_mode as *
                const _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( merge_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . pixel_snap as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( pixel_snap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . oversample_v as *
                const _ as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( oversample_v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . oversample_h as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( oversample_h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . padding as * const _
                as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . size as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . coord_type as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( coord_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . spacing as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( spacing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . range as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . font as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( font ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_config ) ) . fallback_glyph as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_config ) , "::"
                , stringify ! ( fallback_glyph ) ));
}
impl Clone for nk_font_config {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_font_config {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_font_glyph {
    pub codepoint: nk_rune,
    pub xadvance: f32,
    pub x0: f32,
    pub y0: f32,
    pub x1: f32,
    pub y1: f32,
    pub w: f32,
    pub h: f32,
    pub u0: f32,
    pub v0: f32,
    pub u1: f32,
    pub v1: f32,
}
#[test]
fn bindgen_test_layout_nk_font_glyph() {
    assert_eq!(::std::mem::size_of::<nk_font_glyph>() , 48usize , concat ! (
               "Size of: " , stringify ! ( nk_font_glyph ) ));
    assert_eq! (::std::mem::align_of::<nk_font_glyph>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_font_glyph ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . codepoint as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( codepoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . xadvance as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( xadvance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . x0 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( x0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . y0 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( y0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . x1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( x1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . y1 as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( y1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . w as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . h as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . u0 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( u0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . v0 as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( v0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . u1 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( u1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_glyph ) ) . v1 as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_glyph ) , "::"
                , stringify ! ( v1 ) ));
}
impl Clone for nk_font_glyph {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_font {
    pub next: *mut nk_font,
    pub handle: nk_user_font,
    pub info: nk_baked_font,
    pub scale: f32,
    pub glyphs: *mut nk_font_glyph,
    pub fallback: *const nk_font_glyph,
    pub fallback_codepoint: nk_rune,
    pub texture: nk_handle,
    pub config: *mut nk_font_config,
}
#[test]
fn bindgen_test_layout_nk_font() {
    assert_eq!(::std::mem::size_of::<nk_font>() , 128usize , concat ! (
               "Size of: " , stringify ! ( nk_font ) ));
    assert_eq! (::std::mem::align_of::<nk_font>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_font ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font ) ) . next as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font ) ) . handle as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font ) , "::" ,
                stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font ) ) . info as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font ) , "::" ,
                stringify ! ( info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font ) ) . scale as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font ) , "::" ,
                stringify ! ( scale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font ) ) . glyphs as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font ) , "::" ,
                stringify ! ( glyphs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font ) ) . fallback as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font ) , "::" ,
                stringify ! ( fallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font ) ) . fallback_codepoint as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font ) , "::" ,
                stringify ! ( fallback_codepoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font ) ) . texture as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font ) , "::" ,
                stringify ! ( texture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font ) ) . config as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font ) , "::" ,
                stringify ! ( config ) ));
}
impl Clone for nk_font {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_font {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_font_atlas_format {
    NK_FONT_ATLAS_ALPHA8 = 0,
    NK_FONT_ATLAS_RGBA32 = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_font_atlas {
    pub pixel: *mut ::std::os::raw::c_void,
    pub tex_width: ::std::os::raw::c_int,
    pub tex_height: ::std::os::raw::c_int,
    pub permanent: nk_allocator,
    pub temporary: nk_allocator,
    pub custom: nk_recti,
    pub cursors: [nk_cursor; 7usize],
    pub glyph_count: ::std::os::raw::c_int,
    pub glyphs: *mut nk_font_glyph,
    pub default_font: *mut nk_font,
    pub fonts: *mut nk_font,
    pub config: *mut nk_font_config,
    pub font_num: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nk_font_atlas() {
    assert_eq!(::std::mem::size_of::<nk_font_atlas>() , 400usize , concat ! (
               "Size of: " , stringify ! ( nk_font_atlas ) ));
    assert_eq! (::std::mem::align_of::<nk_font_atlas>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_font_atlas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . pixel as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( pixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . tex_width as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( tex_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . tex_height as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( tex_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . permanent as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( permanent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . temporary as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( temporary ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . custom as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( custom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . cursors as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( cursors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . glyph_count as *
                const _ as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( glyph_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . glyphs as * const _
                as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( glyphs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . default_font as *
                const _ as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( default_font ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . fonts as * const _ as
                usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( fonts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . config as * const _
                as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_font_atlas ) ) . font_num as * const _
                as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_font_atlas ) , "::"
                , stringify ! ( font_num ) ));
}
impl Clone for nk_font_atlas {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_font_atlas {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn nk_font_default_glyph_ranges() -> *const nk_rune;
}
extern "C" {
    pub fn nk_font_chinese_glyph_ranges() -> *const nk_rune;
}
extern "C" {
    pub fn nk_font_cyrillic_glyph_ranges() -> *const nk_rune;
}
extern "C" {
    pub fn nk_font_korean_glyph_ranges() -> *const nk_rune;
}
extern "C" {
    pub fn nk_font_atlas_init(arg1: *mut nk_font_atlas,
                              arg2: *mut nk_allocator);
}
extern "C" {
    pub fn nk_font_atlas_init_custom(arg1: *mut nk_font_atlas,
                                     persistent: *mut nk_allocator,
                                     transient: *mut nk_allocator);
}
extern "C" {
    pub fn nk_font_atlas_begin(arg1: *mut nk_font_atlas);
}
extern "C" {
    pub fn nk_font_config(pixel_height: f32) -> nk_font_config;
}
extern "C" {
    pub fn nk_font_atlas_add(arg1: *mut nk_font_atlas,
                             arg2: *const nk_font_config) -> *mut nk_font;
}
extern "C" {
    pub fn nk_font_atlas_add_from_memory(atlas: *mut nk_font_atlas,
                                         memory: *mut ::std::os::raw::c_void,
                                         size: nk_size, height: f32,
                                         config: *const nk_font_config)
     -> *mut nk_font;
}
extern "C" {
    pub fn nk_font_atlas_add_compressed(arg1: *mut nk_font_atlas,
                                        memory: *mut ::std::os::raw::c_void,
                                        size: nk_size, height: f32,
                                        arg2: *const nk_font_config)
     -> *mut nk_font;
}
extern "C" {
    pub fn nk_font_atlas_add_compressed_base85(arg1: *mut nk_font_atlas,
                                               data:
                                                   *const ::std::os::raw::c_char,
                                               height: f32,
                                               config: *const nk_font_config)
     -> *mut nk_font;
}
extern "C" {
    pub fn nk_font_atlas_bake(arg1: *mut nk_font_atlas,
                              width: *mut ::std::os::raw::c_int,
                              height: *mut ::std::os::raw::c_int,
                              arg2: nk_font_atlas_format)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn nk_font_atlas_end(arg1: *mut nk_font_atlas, tex: nk_handle,
                             arg2: *mut nk_draw_null_texture);
}
extern "C" {
    pub fn nk_font_find_glyph(arg1: *mut nk_font, unicode: nk_rune)
     -> *const nk_font_glyph;
}
extern "C" {
    pub fn nk_font_atlas_cleanup(atlas: *mut nk_font_atlas);
}
extern "C" {
    pub fn nk_font_atlas_clear(arg1: *mut nk_font_atlas);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_memory_status {
    pub memory: *mut ::std::os::raw::c_void,
    pub type_: ::std::os::raw::c_uint,
    pub size: nk_size,
    pub allocated: nk_size,
    pub needed: nk_size,
    pub calls: nk_size,
}
#[test]
fn bindgen_test_layout_nk_memory_status() {
    assert_eq!(::std::mem::size_of::<nk_memory_status>() , 48usize , concat !
               ( "Size of: " , stringify ! ( nk_memory_status ) ));
    assert_eq! (::std::mem::align_of::<nk_memory_status>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_memory_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_memory_status ) ) . memory as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_memory_status ) ,
                "::" , stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_memory_status ) ) . type_ as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_memory_status ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_memory_status ) ) . size as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_memory_status ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_memory_status ) ) . allocated as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_memory_status ) ,
                "::" , stringify ! ( allocated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_memory_status ) ) . needed as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_memory_status ) ,
                "::" , stringify ! ( needed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_memory_status ) ) . calls as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_memory_status ) ,
                "::" , stringify ! ( calls ) ));
}
impl Clone for nk_memory_status {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_memory_status {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_allocation_type { NK_BUFFER_FIXED = 0, NK_BUFFER_DYNAMIC = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_buffer_allocation_type {
    NK_BUFFER_FRONT = 0,
    NK_BUFFER_BACK = 1,
    NK_BUFFER_MAX = 2,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_buffer_marker {
    pub active: ::std::os::raw::c_int,
    pub offset: nk_size,
}
#[test]
fn bindgen_test_layout_nk_buffer_marker() {
    assert_eq!(::std::mem::size_of::<nk_buffer_marker>() , 16usize , concat !
               ( "Size of: " , stringify ! ( nk_buffer_marker ) ));
    assert_eq! (::std::mem::align_of::<nk_buffer_marker>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_buffer_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_buffer_marker ) ) . active as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_buffer_marker ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_buffer_marker ) ) . offset as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_buffer_marker ) ,
                "::" , stringify ! ( offset ) ));
}
impl Clone for nk_buffer_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_memory {
    pub ptr: *mut ::std::os::raw::c_void,
    pub size: nk_size,
}
#[test]
fn bindgen_test_layout_nk_memory() {
    assert_eq!(::std::mem::size_of::<nk_memory>() , 16usize , concat ! (
               "Size of: " , stringify ! ( nk_memory ) ));
    assert_eq! (::std::mem::align_of::<nk_memory>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_memory ) ) . ptr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_memory ) , "::" ,
                stringify ! ( ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_memory ) ) . size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_memory ) , "::" ,
                stringify ! ( size ) ));
}
impl Clone for nk_memory {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_memory {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn nk_buffer_init(arg1: *mut nk_buffer, arg2: *const nk_allocator,
                          size: nk_size);
}
extern "C" {
    pub fn nk_buffer_init_fixed(arg1: *mut nk_buffer,
                                memory: *mut ::std::os::raw::c_void,
                                size: nk_size);
}
extern "C" {
    pub fn nk_buffer_info(arg1: *mut nk_memory_status, arg2: *mut nk_buffer);
}
extern "C" {
    pub fn nk_buffer_push(arg1: *mut nk_buffer,
                          type_: nk_buffer_allocation_type,
                          memory: *const ::std::os::raw::c_void,
                          size: nk_size, align: nk_size);
}
extern "C" {
    pub fn nk_buffer_mark(arg1: *mut nk_buffer,
                          type_: nk_buffer_allocation_type);
}
extern "C" {
    pub fn nk_buffer_reset(arg1: *mut nk_buffer,
                           type_: nk_buffer_allocation_type);
}
extern "C" {
    pub fn nk_buffer_clear(arg1: *mut nk_buffer);
}
extern "C" {
    pub fn nk_buffer_free(arg1: *mut nk_buffer);
}
extern "C" {
    pub fn nk_buffer_memory(arg1: *mut nk_buffer)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn nk_buffer_memory_const(arg1: *const nk_buffer)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn nk_buffer_total(arg1: *mut nk_buffer) -> nk_size;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_str {
    pub buffer: nk_buffer,
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nk_str() {
    assert_eq!(::std::mem::size_of::<nk_str>() , 128usize , concat ! (
               "Size of: " , stringify ! ( nk_str ) ));
    assert_eq! (::std::mem::align_of::<nk_str>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_str ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_str ) ) . buffer as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_str ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_str ) ) . len as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_str ) , "::" ,
                stringify ! ( len ) ));
}
impl Clone for nk_str {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_str {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn nk_str_init(arg1: *mut nk_str, arg2: *const nk_allocator,
                       size: nk_size);
}
extern "C" {
    pub fn nk_str_init_fixed(arg1: *mut nk_str,
                             memory: *mut ::std::os::raw::c_void,
                             size: nk_size);
}
extern "C" {
    pub fn nk_str_clear(arg1: *mut nk_str);
}
extern "C" {
    pub fn nk_str_free(arg1: *mut nk_str);
}
extern "C" {
    pub fn nk_str_append_text_char(arg1: *mut nk_str,
                                   arg2: *const ::std::os::raw::c_char,
                                   arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_append_str_char(arg1: *mut nk_str,
                                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_append_text_utf8(arg1: *mut nk_str,
                                   arg2: *const ::std::os::raw::c_char,
                                   arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_append_str_utf8(arg1: *mut nk_str,
                                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_append_text_runes(arg1: *mut nk_str, arg2: *const nk_rune,
                                    arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_append_str_runes(arg1: *mut nk_str, arg2: *const nk_rune)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_insert_at_char(arg1: *mut nk_str,
                                 pos: ::std::os::raw::c_int,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_insert_at_rune(arg1: *mut nk_str,
                                 pos: ::std::os::raw::c_int,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_insert_text_char(arg1: *mut nk_str,
                                   pos: ::std::os::raw::c_int,
                                   arg2: *const ::std::os::raw::c_char,
                                   arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_insert_str_char(arg1: *mut nk_str,
                                  pos: ::std::os::raw::c_int,
                                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_insert_text_utf8(arg1: *mut nk_str,
                                   pos: ::std::os::raw::c_int,
                                   arg2: *const ::std::os::raw::c_char,
                                   arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_insert_str_utf8(arg1: *mut nk_str,
                                  pos: ::std::os::raw::c_int,
                                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_insert_text_runes(arg1: *mut nk_str,
                                    pos: ::std::os::raw::c_int,
                                    arg2: *const nk_rune,
                                    arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_insert_str_runes(arg1: *mut nk_str,
                                   pos: ::std::os::raw::c_int,
                                   arg2: *const nk_rune)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_remove_chars(arg1: *mut nk_str, len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_str_remove_runes(str: *mut nk_str, len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_str_delete_chars(arg1: *mut nk_str, pos: ::std::os::raw::c_int,
                               len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_str_delete_runes(arg1: *mut nk_str, pos: ::std::os::raw::c_int,
                               len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_str_at_char(arg1: *mut nk_str, pos: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nk_str_at_rune(arg1: *mut nk_str, pos: ::std::os::raw::c_int,
                          unicode: *mut nk_rune,
                          len: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nk_str_rune_at(arg1: *const nk_str, pos: ::std::os::raw::c_int)
     -> nk_rune;
}
extern "C" {
    pub fn nk_str_at_char_const(arg1: *const nk_str,
                                pos: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nk_str_at_const(arg1: *const nk_str, pos: ::std::os::raw::c_int,
                           unicode: *mut nk_rune,
                           len: *mut ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nk_str_get(arg1: *mut nk_str) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nk_str_get_const(arg1: *const nk_str)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nk_str_len(arg1: *mut nk_str) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_str_len_char(arg1: *mut nk_str) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_clipboard {
    pub userdata: nk_handle,
    pub paste: nk_plugin_paste,
    pub copy: nk_plugin_copy,
}
#[test]
fn bindgen_test_layout_nk_clipboard() {
    assert_eq!(::std::mem::size_of::<nk_clipboard>() , 24usize , concat ! (
               "Size of: " , stringify ! ( nk_clipboard ) ));
    assert_eq! (::std::mem::align_of::<nk_clipboard>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_clipboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_clipboard ) ) . userdata as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_clipboard ) , "::" ,
                stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_clipboard ) ) . paste as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_clipboard ) , "::" ,
                stringify ! ( paste ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_clipboard ) ) . copy as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_clipboard ) , "::" ,
                stringify ! ( copy ) ));
}
impl Clone for nk_clipboard {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_clipboard {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_text_undo_record {
    pub where_: ::std::os::raw::c_int,
    pub insert_length: ::std::os::raw::c_short,
    pub delete_length: ::std::os::raw::c_short,
    pub char_storage: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_nk_text_undo_record() {
    assert_eq!(::std::mem::size_of::<nk_text_undo_record>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( nk_text_undo_record ) ));
    assert_eq! (::std::mem::align_of::<nk_text_undo_record>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_text_undo_record ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_undo_record ) ) . where_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_undo_record ) ,
                "::" , stringify ! ( where_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_undo_record ) ) . insert_length
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_undo_record ) ,
                "::" , stringify ! ( insert_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_undo_record ) ) . delete_length
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_undo_record ) ,
                "::" , stringify ! ( delete_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_undo_record ) ) . char_storage as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_undo_record ) ,
                "::" , stringify ! ( char_storage ) ));
}
impl Clone for nk_text_undo_record {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct nk_text_undo_state {
    pub undo_rec: [nk_text_undo_record; 99usize],
    pub undo_char: [nk_rune; 999usize],
    pub undo_point: ::std::os::raw::c_short,
    pub redo_point: ::std::os::raw::c_short,
    pub undo_char_point: ::std::os::raw::c_short,
    pub redo_char_point: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_nk_text_undo_state() {
    assert_eq!(::std::mem::size_of::<nk_text_undo_state>() , 5192usize ,
               concat ! ( "Size of: " , stringify ! ( nk_text_undo_state ) ));
    assert_eq! (::std::mem::align_of::<nk_text_undo_state>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( nk_text_undo_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_undo_state ) ) . undo_rec as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_undo_state ) ,
                "::" , stringify ! ( undo_rec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_undo_state ) ) . undo_char as *
                const _ as usize } , 1188usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_undo_state ) ,
                "::" , stringify ! ( undo_char ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_undo_state ) ) . undo_point as *
                const _ as usize } , 5184usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_undo_state ) ,
                "::" , stringify ! ( undo_point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_undo_state ) ) . redo_point as *
                const _ as usize } , 5186usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_undo_state ) ,
                "::" , stringify ! ( redo_point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_undo_state ) ) . undo_char_point
                as * const _ as usize } , 5188usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_undo_state ) ,
                "::" , stringify ! ( undo_char_point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_text_undo_state ) ) . redo_char_point
                as * const _ as usize } , 5190usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_text_undo_state ) ,
                "::" , stringify ! ( redo_char_point ) ));
}
impl Default for nk_text_undo_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_text_edit_type {
    NK_TEXT_EDIT_SINGLE_LINE = 0,
    NK_TEXT_EDIT_MULTI_LINE = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_text_edit_mode {
    NK_TEXT_EDIT_MODE_VIEW = 0,
    NK_TEXT_EDIT_MODE_INSERT = 1,
    NK_TEXT_EDIT_MODE_REPLACE = 2,
}
extern "C" {
    pub fn nk_filter_default(arg1: *const nk_text_edit, unicode: nk_rune)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_filter_ascii(arg1: *const nk_text_edit, unicode: nk_rune)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_filter_float(arg1: *const nk_text_edit, unicode: nk_rune)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_filter_decimal(arg1: *const nk_text_edit, unicode: nk_rune)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_filter_hex(arg1: *const nk_text_edit, unicode: nk_rune)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_filter_oct(arg1: *const nk_text_edit, unicode: nk_rune)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_filter_binary(arg1: *const nk_text_edit, unicode: nk_rune)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_textedit_init(arg1: *mut nk_text_edit, arg2: *mut nk_allocator,
                            size: nk_size);
}
extern "C" {
    pub fn nk_textedit_init_fixed(arg1: *mut nk_text_edit,
                                  memory: *mut ::std::os::raw::c_void,
                                  size: nk_size);
}
extern "C" {
    pub fn nk_textedit_free(arg1: *mut nk_text_edit);
}
extern "C" {
    pub fn nk_textedit_text(arg1: *mut nk_text_edit,
                            arg2: *const ::std::os::raw::c_char,
                            total_len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_textedit_delete(arg1: *mut nk_text_edit,
                              where_: ::std::os::raw::c_int,
                              len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_textedit_delete_selection(arg1: *mut nk_text_edit);
}
extern "C" {
    pub fn nk_textedit_select_all(arg1: *mut nk_text_edit);
}
extern "C" {
    pub fn nk_textedit_cut(arg1: *mut nk_text_edit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_textedit_paste(arg1: *mut nk_text_edit,
                             arg2: *const ::std::os::raw::c_char,
                             len: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_textedit_undo(arg1: *mut nk_text_edit);
}
extern "C" {
    pub fn nk_textedit_redo(arg1: *mut nk_text_edit);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_command_type {
    NK_COMMAND_NOP = 0,
    NK_COMMAND_SCISSOR = 1,
    NK_COMMAND_LINE = 2,
    NK_COMMAND_CURVE = 3,
    NK_COMMAND_RECT = 4,
    NK_COMMAND_RECT_FILLED = 5,
    NK_COMMAND_RECT_MULTI_COLOR = 6,
    NK_COMMAND_CIRCLE = 7,
    NK_COMMAND_CIRCLE_FILLED = 8,
    NK_COMMAND_ARC = 9,
    NK_COMMAND_ARC_FILLED = 10,
    NK_COMMAND_TRIANGLE = 11,
    NK_COMMAND_TRIANGLE_FILLED = 12,
    NK_COMMAND_POLYGON = 13,
    NK_COMMAND_POLYGON_FILLED = 14,
    NK_COMMAND_POLYLINE = 15,
    NK_COMMAND_TEXT = 16,
    NK_COMMAND_IMAGE = 17,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command {
    pub type_: nk_command_type,
    pub next: nk_size,
    pub userdata: nk_handle,
}
#[test]
fn bindgen_test_layout_nk_command() {
    assert_eq!(::std::mem::size_of::<nk_command>() , 24usize , concat ! (
               "Size of: " , stringify ! ( nk_command ) ));
    assert_eq! (::std::mem::align_of::<nk_command>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_command ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command ) ) . userdata as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command ) , "::" ,
                stringify ! ( userdata ) ));
}
impl Clone for nk_command {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_scissor {
    pub header: nk_command,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_ushort,
    pub h: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_nk_command_scissor() {
    assert_eq!(::std::mem::size_of::<nk_command_scissor>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( nk_command_scissor ) ));
    assert_eq! (::std::mem::align_of::<nk_command_scissor>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nk_command_scissor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_scissor ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_scissor ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_scissor ) ) . x as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_scissor ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_scissor ) ) . y as * const _
                as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_scissor ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_scissor ) ) . w as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_scissor ) ,
                "::" , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_scissor ) ) . h as * const _
                as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_scissor ) ,
                "::" , stringify ! ( h ) ));
}
impl Clone for nk_command_scissor {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_scissor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_line {
    pub header: nk_command,
    pub line_thickness: ::std::os::raw::c_ushort,
    pub begin: nk_vec2i,
    pub end: nk_vec2i,
    pub color: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_line() {
    assert_eq!(::std::mem::size_of::<nk_command_line>() , 40usize , concat ! (
               "Size of: " , stringify ! ( nk_command_line ) ));
    assert_eq! (::std::mem::align_of::<nk_command_line>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_command_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_line ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_line ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_line ) ) . line_thickness as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_line ) ,
                "::" , stringify ! ( line_thickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_line ) ) . begin as * const _
                as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_line ) ,
                "::" , stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_line ) ) . end as * const _ as
                usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_line ) ,
                "::" , stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_line ) ) . color as * const _
                as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_line ) ,
                "::" , stringify ! ( color ) ));
}
impl Clone for nk_command_line {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_line {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_curve {
    pub header: nk_command,
    pub line_thickness: ::std::os::raw::c_ushort,
    pub begin: nk_vec2i,
    pub end: nk_vec2i,
    pub ctrl: [nk_vec2i; 2usize],
    pub color: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_curve() {
    assert_eq!(::std::mem::size_of::<nk_command_curve>() , 48usize , concat !
               ( "Size of: " , stringify ! ( nk_command_curve ) ));
    assert_eq! (::std::mem::align_of::<nk_command_curve>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_command_curve ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_curve ) ) . header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_curve ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_curve ) ) . line_thickness as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_curve ) ,
                "::" , stringify ! ( line_thickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_curve ) ) . begin as * const _
                as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_curve ) ,
                "::" , stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_curve ) ) . end as * const _
                as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_curve ) ,
                "::" , stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_curve ) ) . ctrl as * const _
                as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_curve ) ,
                "::" , stringify ! ( ctrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_curve ) ) . color as * const _
                as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_curve ) ,
                "::" , stringify ! ( color ) ));
}
impl Clone for nk_command_curve {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_curve {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_rect {
    pub header: nk_command,
    pub rounding: ::std::os::raw::c_ushort,
    pub line_thickness: ::std::os::raw::c_ushort,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_ushort,
    pub h: ::std::os::raw::c_ushort,
    pub color: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_rect() {
    assert_eq!(::std::mem::size_of::<nk_command_rect>() , 40usize , concat ! (
               "Size of: " , stringify ! ( nk_command_rect ) ));
    assert_eq! (::std::mem::align_of::<nk_command_rect>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_command_rect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect ) ) . rounding as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect ) ,
                "::" , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect ) ) . line_thickness as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect ) ,
                "::" , stringify ! ( line_thickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect ) ) . x as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect ) ) . y as * const _ as
                usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect ) ) . w as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect ) ,
                "::" , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect ) ) . h as * const _ as
                usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect ) ,
                "::" , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect ) ) . color as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect ) ,
                "::" , stringify ! ( color ) ));
}
impl Clone for nk_command_rect {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_rect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_rect_filled {
    pub header: nk_command,
    pub rounding: ::std::os::raw::c_ushort,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_ushort,
    pub h: ::std::os::raw::c_ushort,
    pub color: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_rect_filled() {
    assert_eq!(::std::mem::size_of::<nk_command_rect_filled>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( nk_command_rect_filled )
               ));
    assert_eq! (::std::mem::align_of::<nk_command_rect_filled>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_command_rect_filled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_filled ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect_filled
                ) , "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_filled ) ) . rounding as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect_filled
                ) , "::" , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_filled ) ) . x as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect_filled
                ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_filled ) ) . y as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect_filled
                ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_filled ) ) . w as * const
                _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect_filled
                ) , "::" , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_filled ) ) . h as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect_filled
                ) , "::" , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_filled ) ) . color as *
                const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_rect_filled
                ) , "::" , stringify ! ( color ) ));
}
impl Clone for nk_command_rect_filled {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_rect_filled {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_rect_multi_color {
    pub header: nk_command,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_ushort,
    pub h: ::std::os::raw::c_ushort,
    pub left: nk_color,
    pub top: nk_color,
    pub bottom: nk_color,
    pub right: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_rect_multi_color() {
    assert_eq!(::std::mem::size_of::<nk_command_rect_multi_color>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( nk_command_rect_multi_color ) ));
    assert_eq! (::std::mem::align_of::<nk_command_rect_multi_color>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( nk_command_rect_multi_color )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_multi_color ) ) . header
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_rect_multi_color ) , "::" , stringify ! ( header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_multi_color ) ) . x as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_rect_multi_color ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_multi_color ) ) . y as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_rect_multi_color ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_multi_color ) ) . w as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_rect_multi_color ) , "::" , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_multi_color ) ) . h as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_rect_multi_color ) , "::" , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_multi_color ) ) . left as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_rect_multi_color ) , "::" , stringify ! ( left )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_multi_color ) ) . top as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_rect_multi_color ) , "::" , stringify ! ( top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_multi_color ) ) . bottom
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_rect_multi_color ) , "::" , stringify ! ( bottom )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_rect_multi_color ) ) . right
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_rect_multi_color ) , "::" , stringify ! ( right )
                ));
}
impl Clone for nk_command_rect_multi_color {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_rect_multi_color {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_triangle {
    pub header: nk_command,
    pub line_thickness: ::std::os::raw::c_ushort,
    pub a: nk_vec2i,
    pub b: nk_vec2i,
    pub c: nk_vec2i,
    pub color: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_triangle() {
    assert_eq!(::std::mem::size_of::<nk_command_triangle>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( nk_command_triangle ) ));
    assert_eq! (::std::mem::align_of::<nk_command_triangle>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_command_triangle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_triangle ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_triangle ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_triangle ) ) . line_thickness
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_triangle ) ,
                "::" , stringify ! ( line_thickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_triangle ) ) . a as * const _
                as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_triangle ) ,
                "::" , stringify ! ( a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_triangle ) ) . b as * const _
                as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_triangle ) ,
                "::" , stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_triangle ) ) . c as * const _
                as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_triangle ) ,
                "::" , stringify ! ( c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_triangle ) ) . color as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_triangle ) ,
                "::" , stringify ! ( color ) ));
}
impl Clone for nk_command_triangle {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_triangle {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_triangle_filled {
    pub header: nk_command,
    pub a: nk_vec2i,
    pub b: nk_vec2i,
    pub c: nk_vec2i,
    pub color: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_triangle_filled() {
    assert_eq!(::std::mem::size_of::<nk_command_triangle_filled>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( nk_command_triangle_filled ) ));
    assert_eq! (::std::mem::align_of::<nk_command_triangle_filled>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( nk_command_triangle_filled )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_triangle_filled ) ) . header
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_triangle_filled ) , "::" , stringify ! ( header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_triangle_filled ) ) . a as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_triangle_filled ) , "::" , stringify ! ( a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_triangle_filled ) ) . b as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_triangle_filled ) , "::" , stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_triangle_filled ) ) . c as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_triangle_filled ) , "::" , stringify ! ( c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_triangle_filled ) ) . color as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_triangle_filled ) , "::" , stringify ! ( color )
                ));
}
impl Clone for nk_command_triangle_filled {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_triangle_filled {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_circle {
    pub header: nk_command,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub line_thickness: ::std::os::raw::c_ushort,
    pub w: ::std::os::raw::c_ushort,
    pub h: ::std::os::raw::c_ushort,
    pub color: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_circle() {
    assert_eq!(::std::mem::size_of::<nk_command_circle>() , 40usize , concat !
               ( "Size of: " , stringify ! ( nk_command_circle ) ));
    assert_eq! (::std::mem::align_of::<nk_command_circle>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nk_command_circle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle ) ) . header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_circle ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle ) ) . x as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_circle ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle ) ) . y as * const _ as
                usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_circle ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle ) ) . line_thickness as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_circle ) ,
                "::" , stringify ! ( line_thickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle ) ) . w as * const _ as
                usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_circle ) ,
                "::" , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle ) ) . h as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_circle ) ,
                "::" , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle ) ) . color as * const
                _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_circle ) ,
                "::" , stringify ! ( color ) ));
}
impl Clone for nk_command_circle {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_circle {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_circle_filled {
    pub header: nk_command,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_ushort,
    pub h: ::std::os::raw::c_ushort,
    pub color: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_circle_filled() {
    assert_eq!(::std::mem::size_of::<nk_command_circle_filled>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( nk_command_circle_filled ) ));
    assert_eq! (::std::mem::align_of::<nk_command_circle_filled>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_command_circle_filled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle_filled ) ) . header as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_circle_filled ) , "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle_filled ) ) . x as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_circle_filled ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle_filled ) ) . y as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_circle_filled ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle_filled ) ) . w as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_circle_filled ) , "::" , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle_filled ) ) . h as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_circle_filled ) , "::" , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_circle_filled ) ) . color as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_circle_filled ) , "::" , stringify ! ( color ) ));
}
impl Clone for nk_command_circle_filled {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_circle_filled {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_arc {
    pub header: nk_command,
    pub cx: ::std::os::raw::c_short,
    pub cy: ::std::os::raw::c_short,
    pub r: ::std::os::raw::c_ushort,
    pub line_thickness: ::std::os::raw::c_ushort,
    pub a: [f32; 2usize],
    pub color: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_arc() {
    assert_eq!(::std::mem::size_of::<nk_command_arc>() , 48usize , concat ! (
               "Size of: " , stringify ! ( nk_command_arc ) ));
    assert_eq! (::std::mem::align_of::<nk_command_arc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_command_arc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc ) , "::"
                , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc ) ) . cx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc ) , "::"
                , stringify ! ( cx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc ) ) . cy as * const _ as
                usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc ) , "::"
                , stringify ! ( cy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc ) ) . r as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc ) , "::"
                , stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc ) ) . line_thickness as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc ) , "::"
                , stringify ! ( line_thickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc ) ) . a as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc ) , "::"
                , stringify ! ( a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc ) ) . color as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc ) , "::"
                , stringify ! ( color ) ));
}
impl Clone for nk_command_arc {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_arc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_arc_filled {
    pub header: nk_command,
    pub cx: ::std::os::raw::c_short,
    pub cy: ::std::os::raw::c_short,
    pub r: ::std::os::raw::c_ushort,
    pub a: [f32; 2usize],
    pub color: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_arc_filled() {
    assert_eq!(::std::mem::size_of::<nk_command_arc_filled>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( nk_command_arc_filled )
               ));
    assert_eq! (::std::mem::align_of::<nk_command_arc_filled>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_command_arc_filled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc_filled ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc_filled )
                , "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc_filled ) ) . cx as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc_filled )
                , "::" , stringify ! ( cx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc_filled ) ) . cy as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc_filled )
                , "::" , stringify ! ( cy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc_filled ) ) . r as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc_filled )
                , "::" , stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc_filled ) ) . a as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc_filled )
                , "::" , stringify ! ( a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_arc_filled ) ) . color as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_arc_filled )
                , "::" , stringify ! ( color ) ));
}
impl Clone for nk_command_arc_filled {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_arc_filled {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_polygon {
    pub header: nk_command,
    pub color: nk_color,
    pub line_thickness: ::std::os::raw::c_ushort,
    pub point_count: ::std::os::raw::c_ushort,
    pub points: [nk_vec2i; 1usize],
}
#[test]
fn bindgen_test_layout_nk_command_polygon() {
    assert_eq!(::std::mem::size_of::<nk_command_polygon>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( nk_command_polygon ) ));
    assert_eq! (::std::mem::align_of::<nk_command_polygon>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nk_command_polygon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polygon ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_polygon ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polygon ) ) . color as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_polygon ) ,
                "::" , stringify ! ( color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polygon ) ) . line_thickness
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_polygon ) ,
                "::" , stringify ! ( line_thickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polygon ) ) . point_count as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_polygon ) ,
                "::" , stringify ! ( point_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polygon ) ) . points as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_polygon ) ,
                "::" , stringify ! ( points ) ));
}
impl Clone for nk_command_polygon {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_polygon {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_polygon_filled {
    pub header: nk_command,
    pub color: nk_color,
    pub point_count: ::std::os::raw::c_ushort,
    pub points: [nk_vec2i; 1usize],
}
#[test]
fn bindgen_test_layout_nk_command_polygon_filled() {
    assert_eq!(::std::mem::size_of::<nk_command_polygon_filled>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( nk_command_polygon_filled ) ));
    assert_eq! (::std::mem::align_of::<nk_command_polygon_filled>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_command_polygon_filled )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polygon_filled ) ) . header as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_polygon_filled ) , "::" , stringify ! ( header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polygon_filled ) ) . color as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_polygon_filled ) , "::" , stringify ! ( color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polygon_filled ) ) .
                point_count as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_polygon_filled ) , "::" , stringify ! ( point_count
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polygon_filled ) ) . points as
                * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_command_polygon_filled ) , "::" , stringify ! ( points )
                ));
}
impl Clone for nk_command_polygon_filled {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_polygon_filled {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_polyline {
    pub header: nk_command,
    pub color: nk_color,
    pub line_thickness: ::std::os::raw::c_ushort,
    pub point_count: ::std::os::raw::c_ushort,
    pub points: [nk_vec2i; 1usize],
}
#[test]
fn bindgen_test_layout_nk_command_polyline() {
    assert_eq!(::std::mem::size_of::<nk_command_polyline>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( nk_command_polyline ) ));
    assert_eq! (::std::mem::align_of::<nk_command_polyline>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_command_polyline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polyline ) ) . header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_polyline ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polyline ) ) . color as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_polyline ) ,
                "::" , stringify ! ( color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polyline ) ) . line_thickness
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_polyline ) ,
                "::" , stringify ! ( line_thickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polyline ) ) . point_count as
                * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_polyline ) ,
                "::" , stringify ! ( point_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_polyline ) ) . points as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_polyline ) ,
                "::" , stringify ! ( points ) ));
}
impl Clone for nk_command_polyline {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_polyline {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_image {
    pub header: nk_command,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_ushort,
    pub h: ::std::os::raw::c_ushort,
    pub img: nk_image,
    pub col: nk_color,
}
#[test]
fn bindgen_test_layout_nk_command_image() {
    assert_eq!(::std::mem::size_of::<nk_command_image>() , 64usize , concat !
               ( "Size of: " , stringify ! ( nk_command_image ) ));
    assert_eq! (::std::mem::align_of::<nk_command_image>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_command_image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_image ) ) . header as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_image ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_image ) ) . x as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_image ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_image ) ) . y as * const _ as
                usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_image ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_image ) ) . w as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_image ) ,
                "::" , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_image ) ) . h as * const _ as
                usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_image ) ,
                "::" , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_image ) ) . img as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_image ) ,
                "::" , stringify ! ( img ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_image ) ) . col as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_image ) ,
                "::" , stringify ! ( col ) ));
}
impl Clone for nk_command_image {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_image {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_command_text {
    pub header: nk_command,
    pub font: *const nk_user_font,
    pub background: nk_color,
    pub foreground: nk_color,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_ushort,
    pub h: ::std::os::raw::c_ushort,
    pub height: f32,
    pub length: ::std::os::raw::c_int,
    pub string: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_nk_command_text() {
    assert_eq!(::std::mem::size_of::<nk_command_text>() , 64usize , concat ! (
               "Size of: " , stringify ! ( nk_command_text ) ));
    assert_eq! (::std::mem::align_of::<nk_command_text>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_command_text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_text ) ) . header as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_text ) ,
                "::" , stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_text ) ) . font as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_text ) ,
                "::" , stringify ! ( font ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_text ) ) . background as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_text ) ,
                "::" , stringify ! ( background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_text ) ) . foreground as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_text ) ,
                "::" , stringify ! ( foreground ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_text ) ) . x as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_text ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_text ) ) . y as * const _ as
                usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_text ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_text ) ) . w as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_text ) ,
                "::" , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_text ) ) . h as * const _ as
                usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_text ) ,
                "::" , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_text ) ) . height as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_text ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_text ) ) . length as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_text ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_command_text ) ) . string as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_command_text ) ,
                "::" , stringify ! ( string ) ));
}
impl Clone for nk_command_text {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_command_text {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_command_clipping { NK_CLIPPING_OFF = 0, NK_CLIPPING_ON = 1, }
extern "C" {
    pub fn nk_stroke_line(b: *mut nk_command_buffer, x0: f32, y0: f32,
                          x1: f32, y1: f32, line_thickness: f32,
                          arg1: nk_color);
}
extern "C" {
    pub fn nk_stroke_curve(arg1: *mut nk_command_buffer, arg2: f32, arg3: f32,
                           arg4: f32, arg5: f32, arg6: f32, arg7: f32,
                           arg8: f32, arg9: f32, line_thickness: f32,
                           arg10: nk_color);
}
extern "C" {
    pub fn nk_stroke_rect(arg1: *mut nk_command_buffer, arg2: nk_rect,
                          rounding: f32, line_thickness: f32, arg3: nk_color);
}
extern "C" {
    pub fn nk_stroke_circle(arg1: *mut nk_command_buffer, arg2: nk_rect,
                            line_thickness: f32, arg3: nk_color);
}
extern "C" {
    pub fn nk_stroke_arc(arg1: *mut nk_command_buffer, cx: f32, cy: f32,
                         radius: f32, a_min: f32, a_max: f32,
                         line_thickness: f32, arg2: nk_color);
}
extern "C" {
    pub fn nk_stroke_triangle(arg1: *mut nk_command_buffer, arg2: f32,
                              arg3: f32, arg4: f32, arg5: f32, arg6: f32,
                              arg7: f32, line_thichness: f32, arg8: nk_color);
}
extern "C" {
    pub fn nk_stroke_polyline(arg1: *mut nk_command_buffer, points: *mut f32,
                              point_count: ::std::os::raw::c_int,
                              line_thickness: f32, col: nk_color);
}
extern "C" {
    pub fn nk_stroke_polygon(arg1: *mut nk_command_buffer, arg2: *mut f32,
                             point_count: ::std::os::raw::c_int,
                             line_thickness: f32, arg3: nk_color);
}
extern "C" {
    pub fn nk_fill_rect(arg1: *mut nk_command_buffer, arg2: nk_rect,
                        rounding: f32, arg3: nk_color);
}
extern "C" {
    pub fn nk_fill_rect_multi_color(arg1: *mut nk_command_buffer,
                                    arg2: nk_rect, left: nk_color,
                                    top: nk_color, right: nk_color,
                                    bottom: nk_color);
}
extern "C" {
    pub fn nk_fill_circle(arg1: *mut nk_command_buffer, arg2: nk_rect,
                          arg3: nk_color);
}
extern "C" {
    pub fn nk_fill_arc(arg1: *mut nk_command_buffer, cx: f32, cy: f32,
                       radius: f32, a_min: f32, a_max: f32, arg2: nk_color);
}
extern "C" {
    pub fn nk_fill_triangle(arg1: *mut nk_command_buffer, x0: f32, y0: f32,
                            x1: f32, y1: f32, x2: f32, y2: f32,
                            arg2: nk_color);
}
extern "C" {
    pub fn nk_fill_polygon(arg1: *mut nk_command_buffer, arg2: *mut f32,
                           point_count: ::std::os::raw::c_int,
                           arg3: nk_color);
}
extern "C" {
    pub fn nk_push_scissor(arg1: *mut nk_command_buffer, arg2: nk_rect);
}
extern "C" {
    pub fn nk_draw_image(arg1: *mut nk_command_buffer, arg2: nk_rect,
                         arg3: *const nk_image, arg4: nk_color);
}
extern "C" {
    pub fn nk_draw_text(arg1: *mut nk_command_buffer, arg2: nk_rect,
                        text: *const ::std::os::raw::c_char,
                        len: ::std::os::raw::c_int, arg3: *const nk_user_font,
                        arg4: nk_color, arg5: nk_color);
}
extern "C" {
    pub fn nk__next(arg1: *mut nk_context, arg2: *const nk_command)
     -> *const nk_command;
}
extern "C" {
    pub fn nk__begin(arg1: *mut nk_context) -> *const nk_command;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_mouse_button {
    pub down: ::std::os::raw::c_int,
    pub clicked: ::std::os::raw::c_uint,
    pub clicked_pos: nk_vec2,
}
#[test]
fn bindgen_test_layout_nk_mouse_button() {
    assert_eq!(::std::mem::size_of::<nk_mouse_button>() , 16usize , concat ! (
               "Size of: " , stringify ! ( nk_mouse_button ) ));
    assert_eq! (::std::mem::align_of::<nk_mouse_button>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( nk_mouse_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_mouse_button ) ) . down as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_mouse_button ) ,
                "::" , stringify ! ( down ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_mouse_button ) ) . clicked as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_mouse_button ) ,
                "::" , stringify ! ( clicked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_mouse_button ) ) . clicked_pos as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_mouse_button ) ,
                "::" , stringify ! ( clicked_pos ) ));
}
impl Clone for nk_mouse_button {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_mouse {
    pub buttons: [nk_mouse_button; 3usize],
    pub pos: nk_vec2,
    pub prev: nk_vec2,
    pub delta: nk_vec2,
    pub scroll_delta: f32,
    pub grab: ::std::os::raw::c_uchar,
    pub grabbed: ::std::os::raw::c_uchar,
    pub ungrab: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_nk_mouse() {
    assert_eq!(::std::mem::size_of::<nk_mouse>() , 80usize , concat ! (
               "Size of: " , stringify ! ( nk_mouse ) ));
    assert_eq! (::std::mem::align_of::<nk_mouse>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_mouse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_mouse ) ) . buttons as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_mouse ) , "::" ,
                stringify ! ( buttons ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_mouse ) ) . pos as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_mouse ) , "::" ,
                stringify ! ( pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_mouse ) ) . prev as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_mouse ) , "::" ,
                stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_mouse ) ) . delta as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_mouse ) , "::" ,
                stringify ! ( delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_mouse ) ) . scroll_delta as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_mouse ) , "::" ,
                stringify ! ( scroll_delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_mouse ) ) . grab as * const _ as usize
                } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_mouse ) , "::" ,
                stringify ! ( grab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_mouse ) ) . grabbed as * const _ as
                usize } , 77usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_mouse ) , "::" ,
                stringify ! ( grabbed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_mouse ) ) . ungrab as * const _ as
                usize } , 78usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_mouse ) , "::" ,
                stringify ! ( ungrab ) ));
}
impl Clone for nk_mouse {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_key {
    pub down: ::std::os::raw::c_int,
    pub clicked: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nk_key() {
    assert_eq!(::std::mem::size_of::<nk_key>() , 8usize , concat ! (
               "Size of: " , stringify ! ( nk_key ) ));
    assert_eq! (::std::mem::align_of::<nk_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_key ) ) . down as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_key ) , "::" ,
                stringify ! ( down ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_key ) ) . clicked as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_key ) , "::" ,
                stringify ! ( clicked ) ));
}
impl Clone for nk_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_keyboard {
    pub keys: [nk_key; 30usize],
    pub text: [::std::os::raw::c_char; 16usize],
    pub text_len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nk_keyboard() {
    assert_eq!(::std::mem::size_of::<nk_keyboard>() , 260usize , concat ! (
               "Size of: " , stringify ! ( nk_keyboard ) ));
    assert_eq! (::std::mem::align_of::<nk_keyboard>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_keyboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_keyboard ) ) . keys as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_keyboard ) , "::" ,
                stringify ! ( keys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_keyboard ) ) . text as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_keyboard ) , "::" ,
                stringify ! ( text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_keyboard ) ) . text_len as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_keyboard ) , "::" ,
                stringify ! ( text_len ) ));
}
impl Clone for nk_keyboard {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_input {
    pub keyboard: nk_keyboard,
    pub mouse: nk_mouse,
}
#[test]
fn bindgen_test_layout_nk_input() {
    assert_eq!(::std::mem::size_of::<nk_input>() , 340usize , concat ! (
               "Size of: " , stringify ! ( nk_input ) ));
    assert_eq! (::std::mem::align_of::<nk_input>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_input ) ) . keyboard as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_input ) , "::" ,
                stringify ! ( keyboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_input ) ) . mouse as * const _ as
                usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_input ) , "::" ,
                stringify ! ( mouse ) ));
}
impl Clone for nk_input {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn nk_input_has_mouse_click(arg1: *const nk_input, arg2: nk_buttons)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_has_mouse_click_in_rect(arg1: *const nk_input,
                                            arg2: nk_buttons, arg3: nk_rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_has_mouse_click_down_in_rect(arg1: *const nk_input,
                                                 arg2: nk_buttons,
                                                 arg3: nk_rect,
                                                 down: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_is_mouse_click_in_rect(arg1: *const nk_input,
                                           arg2: nk_buttons, arg3: nk_rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_is_mouse_click_down_in_rect(i: *const nk_input,
                                                id: nk_buttons, b: nk_rect,
                                                down: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_any_mouse_click_in_rect(arg1: *const nk_input,
                                            arg2: nk_rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_is_mouse_prev_hovering_rect(arg1: *const nk_input,
                                                arg2: nk_rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_is_mouse_hovering_rect(arg1: *const nk_input,
                                           arg2: nk_rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_mouse_clicked(arg1: *const nk_input, arg2: nk_buttons,
                                  arg3: nk_rect) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_is_mouse_down(arg1: *const nk_input, arg2: nk_buttons)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_is_mouse_pressed(arg1: *const nk_input, arg2: nk_buttons)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_is_mouse_released(arg1: *const nk_input, arg2: nk_buttons)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_is_key_pressed(arg1: *const nk_input, arg2: nk_keys)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_is_key_released(arg1: *const nk_input, arg2: nk_keys)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nk_input_is_key_down(arg1: *const nk_input, arg2: nk_keys)
     -> ::std::os::raw::c_int;
}
pub type nk_draw_index = nk_ushort;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_draw_list_stroke { NK_STROKE_OPEN = 0, NK_STROKE_CLOSED = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_draw_vertex_layout_attribute {
    NK_VERTEX_POSITION = 0,
    NK_VERTEX_COLOR = 1,
    NK_VERTEX_TEXCOORD = 2,
    NK_VERTEX_ATTRIBUTE_COUNT = 3,
}
pub const nk_draw_vertex_layout_format_NK_FORMAT_R8G8B8:
          nk_draw_vertex_layout_format =
    nk_draw_vertex_layout_format::NK_FORMAT_COLOR_BEGIN;
pub const nk_draw_vertex_layout_format_NK_FORMAT_COLOR_END:
          nk_draw_vertex_layout_format =
    nk_draw_vertex_layout_format::NK_FORMAT_RGBA32;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_draw_vertex_layout_format {
    NK_FORMAT_SCHAR = 0,
    NK_FORMAT_SSHORT = 1,
    NK_FORMAT_SINT = 2,
    NK_FORMAT_UCHAR = 3,
    NK_FORMAT_USHORT = 4,
    NK_FORMAT_UINT = 5,
    NK_FORMAT_FLOAT = 6,
    NK_FORMAT_DOUBLE = 7,
    NK_FORMAT_COLOR_BEGIN = 8,
    NK_FORMAT_R16G15B16 = 9,
    NK_FORMAT_R32G32B32 = 10,
    NK_FORMAT_R8G8B8A8 = 11,
    NK_FORMAT_R16G15B16A16 = 12,
    NK_FORMAT_R32G32B32A32 = 13,
    NK_FORMAT_R32G32B32A32_FLOAT = 14,
    NK_FORMAT_R32G32B32A32_DOUBLE = 15,
    NK_FORMAT_RGB32 = 16,
    NK_FORMAT_RGBA32 = 17,
    NK_FORMAT_COUNT = 18,
}
extern "C" {
    pub fn nk_draw_list_init(arg1: *mut nk_draw_list);
}
extern "C" {
    pub fn nk_draw_list_setup(arg1: *mut nk_draw_list,
                              arg2: *const nk_convert_config,
                              cmds: *mut nk_buffer, vertices: *mut nk_buffer,
                              elements: *mut nk_buffer);
}
extern "C" {
    pub fn nk_draw_list_clear(arg1: *mut nk_draw_list);
}
extern "C" {
    pub fn nk__draw_list_begin(arg1: *const nk_draw_list,
                               arg2: *const nk_buffer)
     -> *const nk_draw_command;
}
extern "C" {
    pub fn nk__draw_list_next(arg1: *const nk_draw_command,
                              arg2: *const nk_buffer,
                              arg3: *const nk_draw_list)
     -> *const nk_draw_command;
}
extern "C" {
    pub fn nk__draw_list_end(arg1: *const nk_draw_list,
                             arg2: *const nk_buffer)
     -> *const nk_draw_command;
}
extern "C" {
    pub fn nk_draw_list_path_clear(arg1: *mut nk_draw_list);
}
extern "C" {
    pub fn nk_draw_list_path_line_to(arg1: *mut nk_draw_list, pos: nk_vec2);
}
extern "C" {
    pub fn nk_draw_list_path_arc_to_fast(arg1: *mut nk_draw_list,
                                         center: nk_vec2, radius: f32,
                                         a_min: ::std::os::raw::c_int,
                                         a_max: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nk_draw_list_path_arc_to(arg1: *mut nk_draw_list, center: nk_vec2,
                                    radius: f32, a_min: f32, a_max: f32,
                                    segments: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn nk_draw_list_path_rect_to(arg1: *mut nk_draw_list, a: nk_vec2,
                                     b: nk_vec2, rounding: f32);
}
extern "C" {
    pub fn nk_draw_list_path_curve_to(arg1: *mut nk_draw_list, p2: nk_vec2,
                                      p3: nk_vec2, p4: nk_vec2,
                                      num_segments: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn nk_draw_list_path_fill(arg1: *mut nk_draw_list, arg2: nk_color);
}
extern "C" {
    pub fn nk_draw_list_path_stroke(arg1: *mut nk_draw_list, arg2: nk_color,
                                    closed: nk_draw_list_stroke,
                                    thickness: f32);
}
extern "C" {
    pub fn nk_draw_list_stroke_line(arg1: *mut nk_draw_list, a: nk_vec2,
                                    b: nk_vec2, arg2: nk_color,
                                    thickness: f32);
}
extern "C" {
    pub fn nk_draw_list_stroke_rect(arg1: *mut nk_draw_list, rect: nk_rect,
                                    arg2: nk_color, rounding: f32,
                                    thickness: f32);
}
extern "C" {
    pub fn nk_draw_list_stroke_triangle(arg1: *mut nk_draw_list, a: nk_vec2,
                                        b: nk_vec2, c: nk_vec2,
                                        arg2: nk_color, thickness: f32);
}
extern "C" {
    pub fn nk_draw_list_stroke_circle(arg1: *mut nk_draw_list,
                                      center: nk_vec2, radius: f32,
                                      arg2: nk_color,
                                      segs: ::std::os::raw::c_uint,
                                      thickness: f32);
}
extern "C" {
    pub fn nk_draw_list_stroke_curve(arg1: *mut nk_draw_list, p0: nk_vec2,
                                     cp0: nk_vec2, cp1: nk_vec2, p1: nk_vec2,
                                     arg2: nk_color,
                                     segments: ::std::os::raw::c_uint,
                                     thickness: f32);
}
extern "C" {
    pub fn nk_draw_list_stroke_poly_line(arg1: *mut nk_draw_list,
                                         pnts: *const nk_vec2,
                                         cnt: ::std::os::raw::c_uint,
                                         arg2: nk_color,
                                         arg3: nk_draw_list_stroke,
                                         thickness: f32,
                                         arg4: nk_anti_aliasing);
}
extern "C" {
    pub fn nk_draw_list_fill_rect(arg1: *mut nk_draw_list, rect: nk_rect,
                                  arg2: nk_color, rounding: f32);
}
extern "C" {
    pub fn nk_draw_list_fill_rect_multi_color(arg1: *mut nk_draw_list,
                                              rect: nk_rect, left: nk_color,
                                              top: nk_color, right: nk_color,
                                              bottom: nk_color);
}
extern "C" {
    pub fn nk_draw_list_fill_triangle(arg1: *mut nk_draw_list, a: nk_vec2,
                                      b: nk_vec2, c: nk_vec2, arg2: nk_color);
}
extern "C" {
    pub fn nk_draw_list_fill_circle(arg1: *mut nk_draw_list, center: nk_vec2,
                                    radius: f32, col: nk_color,
                                    segs: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn nk_draw_list_fill_poly_convex(arg1: *mut nk_draw_list,
                                         points: *const nk_vec2,
                                         count: ::std::os::raw::c_uint,
                                         arg2: nk_color,
                                         arg3: nk_anti_aliasing);
}
extern "C" {
    pub fn nk_draw_list_add_image(arg1: *mut nk_draw_list, texture: nk_image,
                                  rect: nk_rect, arg2: nk_color);
}
extern "C" {
    pub fn nk_draw_list_add_text(arg1: *mut nk_draw_list,
                                 arg2: *const nk_user_font, arg3: nk_rect,
                                 text: *const ::std::os::raw::c_char,
                                 len: ::std::os::raw::c_int, font_height: f32,
                                 arg4: nk_color);
}
extern "C" {
    pub fn nk_draw_list_push_userdata(arg1: *mut nk_draw_list,
                                      userdata: nk_handle);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_style_item_type {
    NK_STYLE_ITEM_COLOR = 0,
    NK_STYLE_ITEM_IMAGE = 1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_style_item_data {
    pub image: __BindgenUnionField<nk_image>,
    pub color: __BindgenUnionField<nk_color>,
    pub bindgen_union_field: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_nk_style_item_data() {
    assert_eq!(::std::mem::size_of::<nk_style_item_data>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( nk_style_item_data ) ));
    assert_eq! (::std::mem::align_of::<nk_style_item_data>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nk_style_item_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_item_data ) ) . image as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_item_data ) ,
                "::" , stringify ! ( image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_item_data ) ) . color as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_item_data ) ,
                "::" , stringify ! ( color ) ));
}
impl Clone for nk_style_item_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_style_text {
    pub color: nk_color,
    pub padding: nk_vec2,
}
#[test]
fn bindgen_test_layout_nk_style_text() {
    assert_eq!(::std::mem::size_of::<nk_style_text>() , 12usize , concat ! (
               "Size of: " , stringify ! ( nk_style_text ) ));
    assert_eq! (::std::mem::align_of::<nk_style_text>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_style_text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_text ) ) . color as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_text ) , "::"
                , stringify ! ( color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_text ) ) . padding as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_text ) , "::"
                , stringify ! ( padding ) ));
}
impl Clone for nk_style_text {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style_slider {
    pub normal: nk_style_item,
    pub hover: nk_style_item,
    pub active: nk_style_item,
    pub border_color: nk_color,
    pub bar_normal: nk_color,
    pub bar_hover: nk_color,
    pub bar_active: nk_color,
    pub bar_filled: nk_color,
    pub cursor_normal: nk_style_item,
    pub cursor_hover: nk_style_item,
    pub cursor_active: nk_style_item,
    pub border: f32,
    pub rounding: f32,
    pub bar_height: f32,
    pub padding: nk_vec2,
    pub spacing: nk_vec2,
    pub cursor_size: nk_vec2,
    pub show_buttons: ::std::os::raw::c_int,
    pub inc_button: nk_style_button,
    pub dec_button: nk_style_button,
    pub inc_symbol: nk_symbol_type,
    pub dec_symbol: nk_symbol_type,
    pub userdata: nk_handle,
    pub draw_begin: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut nk_command_buffer,
                                                               arg2:
                                                                   nk_handle)>,
    pub draw_end: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut nk_command_buffer,
                                                             arg2:
                                                                 nk_handle)>,
}
#[test]
fn bindgen_test_layout_nk_style_slider() {
    assert_eq!(::std::mem::size_of::<nk_style_slider>() , 640usize , concat !
               ( "Size of: " , stringify ! ( nk_style_slider ) ));
    assert_eq! (::std::mem::align_of::<nk_style_slider>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_style_slider ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . normal as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . hover as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . active as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . border_color as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( border_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . bar_normal as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( bar_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . bar_hover as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( bar_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . bar_active as *
                const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( bar_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . bar_filled as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( bar_filled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . cursor_normal as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( cursor_normal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . cursor_hover as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( cursor_hover ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . cursor_active as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( cursor_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . border as * const _
                as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( border ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . rounding as * const
                _ as usize } , 220usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( rounding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . bar_height as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( bar_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . padding as * const
                _ as usize } , 228usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . spacing as * const
                _ as usize } , 236usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( spacing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . cursor_size as *
                const _ as usize } , 244usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( cursor_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . show_buttons as *
                const _ as usize } , 252usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( show_buttons ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . inc_button as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( inc_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . dec_button as *
                const _ as usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( dec_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . inc_symbol as *
                const _ as usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( inc_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . dec_symbol as *
                const _ as usize } , 612usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( dec_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . userdata as * const
                _ as usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . draw_begin as *
                const _ as usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( draw_begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style_slider ) ) . draw_end as * const
                _ as usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style_slider ) ,
                "::" , stringify ! ( draw_end ) ));
}
impl Clone for nk_style_slider {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style_slider {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_style_header_align { NK_HEADER_LEFT = 0, NK_HEADER_RIGHT = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_style {
    pub font: *const nk_user_font,
    pub cursors: [*const nk_cursor; 7usize],
    pub cursor_active: *const nk_cursor,
    pub cursor_last: *mut nk_cursor,
    pub cursor_visible: ::std::os::raw::c_int,
    pub text: nk_style_text,
    pub button: nk_style_button,
    pub contextual_button: nk_style_button,
    pub menu_button: nk_style_button,
    pub option: nk_style_toggle,
    pub checkbox: nk_style_toggle,
    pub selectable: nk_style_selectable,
    pub slider: nk_style_slider,
    pub progress: nk_style_progress,
    pub property: nk_style_property,
    pub edit: nk_style_edit,
    pub chart: nk_style_chart,
    pub scrollh: nk_style_scrollbar,
    pub scrollv: nk_style_scrollbar,
    pub tab: nk_style_tab,
    pub combo: nk_style_combo,
    pub window: nk_style_window,
}
#[test]
fn bindgen_test_layout_nk_style() {
    assert_eq!(::std::mem::size_of::<nk_style>() , 7536usize , concat ! (
               "Size of: " , stringify ! ( nk_style ) ));
    assert_eq! (::std::mem::align_of::<nk_style>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_style ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . font as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( font ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . cursors as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( cursors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . cursor_active as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( cursor_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . cursor_last as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( cursor_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . cursor_visible as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( cursor_visible ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . text as * const _ as usize
                } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . button as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . contextual_button as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( contextual_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . menu_button as * const _
                as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( menu_button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . option as * const _ as
                usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( option ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . checkbox as * const _ as
                usize } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( checkbox ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . selectable as * const _ as
                usize } , 1104usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( selectable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . slider as * const _ as
                usize } , 1384usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( slider ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . progress as * const _ as
                usize } , 2024usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( progress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . property as * const _ as
                usize } , 2280usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . edit as * const _ as usize
                } , 3592usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( edit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . chart as * const _ as
                usize } , 4392usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( chart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . scrollh as * const _ as
                usize } , 4456usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( scrollh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . scrollv as * const _ as
                usize } , 5072usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( scrollv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . tab as * const _ as usize
                } , 5688usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( tab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . combo as * const _ as
                usize } , 6472usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( combo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_style ) ) . window as * const _ as
                usize } , 6824usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_style ) , "::" ,
                stringify ! ( window ) ));
}
impl Clone for nk_style {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_style {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn nk_style_item_image(img: nk_image) -> nk_style_item;
}
extern "C" {
    pub fn nk_style_item_color(arg1: nk_color) -> nk_style_item;
}
extern "C" {
    pub fn nk_style_item_hide() -> nk_style_item;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_panel_type {
    NK_PANEL_WINDOW = 1,
    NK_PANEL_GROUP = 2,
    NK_PANEL_POPUP = 4,
    NK_PANEL_CONTEXTUAL = 16,
    NK_PANEL_COMBO = 32,
    NK_PANEL_MENU = 64,
    NK_PANEL_TOOLTIP = 128,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_panel_set {
    NK_PANEL_SET_NONBLOCK = 240,
    NK_PANEL_SET_POPUP = 244,
    NK_PANEL_SET_SUB = 246,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_chart_slot {
    pub type_: nk_chart_type,
    pub color: nk_color,
    pub highlight: nk_color,
    pub min: f32,
    pub max: f32,
    pub range: f32,
    pub count: ::std::os::raw::c_int,
    pub last: nk_vec2,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nk_chart_slot() {
    assert_eq!(::std::mem::size_of::<nk_chart_slot>() , 40usize , concat ! (
               "Size of: " , stringify ! ( nk_chart_slot ) ));
    assert_eq! (::std::mem::align_of::<nk_chart_slot>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_chart_slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart_slot ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart_slot ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart_slot ) ) . color as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart_slot ) , "::"
                , stringify ! ( color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart_slot ) ) . highlight as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart_slot ) , "::"
                , stringify ! ( highlight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart_slot ) ) . min as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart_slot ) , "::"
                , stringify ! ( min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart_slot ) ) . max as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart_slot ) , "::"
                , stringify ! ( max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart_slot ) ) . range as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart_slot ) , "::"
                , stringify ! ( range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart_slot ) ) . count as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart_slot ) , "::"
                , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart_slot ) ) . last as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart_slot ) , "::"
                , stringify ! ( last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart_slot ) ) . index as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart_slot ) , "::"
                , stringify ! ( index ) ));
}
impl Clone for nk_chart_slot {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_chart_slot {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_chart {
    pub slot: ::std::os::raw::c_int,
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
    pub slots: [nk_chart_slot; 4usize],
}
#[test]
fn bindgen_test_layout_nk_chart() {
    assert_eq!(::std::mem::size_of::<nk_chart>() , 180usize , concat ! (
               "Size of: " , stringify ! ( nk_chart ) ));
    assert_eq! (::std::mem::align_of::<nk_chart>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_chart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart ) ) . slot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart ) , "::" ,
                stringify ! ( slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart ) ) . x as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart ) ) . y as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart ) ) . w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart ) , "::" ,
                stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart ) ) . h as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart ) , "::" ,
                stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_chart ) ) . slots as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_chart ) , "::" ,
                stringify ! ( slots ) ));
}
impl Clone for nk_chart {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_chart {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_panel_row_layout_type {
    NK_LAYOUT_DYNAMIC_FIXED = 0,
    NK_LAYOUT_DYNAMIC_ROW = 1,
    NK_LAYOUT_DYNAMIC_FREE = 2,
    NK_LAYOUT_DYNAMIC = 3,
    NK_LAYOUT_STATIC_FIXED = 4,
    NK_LAYOUT_STATIC_ROW = 5,
    NK_LAYOUT_STATIC_FREE = 6,
    NK_LAYOUT_STATIC = 7,
    NK_LAYOUT_TEMPLATE = 8,
    NK_LAYOUT_COUNT = 9,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_row_layout {
    pub type_: nk_panel_row_layout_type,
    pub index: ::std::os::raw::c_int,
    pub height: f32,
    pub columns: ::std::os::raw::c_int,
    pub ratio: *const f32,
    pub item_width: f32,
    pub item_height: f32,
    pub item_offset: f32,
    pub filled: f32,
    pub item: nk_rect,
    pub tree_depth: ::std::os::raw::c_int,
    pub templates: [f32; 16usize],
}
#[test]
fn bindgen_test_layout_nk_row_layout() {
    assert_eq!(::std::mem::size_of::<nk_row_layout>() , 128usize , concat ! (
               "Size of: " , stringify ! ( nk_row_layout ) ));
    assert_eq! (::std::mem::align_of::<nk_row_layout>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_row_layout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . index as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . height as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . columns as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( columns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . ratio as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( ratio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . item_width as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( item_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . item_height as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( item_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . item_offset as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( item_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . filled as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( filled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . item as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( item ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . tree_depth as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( tree_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_row_layout ) ) . templates as * const
                _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_row_layout ) , "::"
                , stringify ! ( templates ) ));
}
impl Clone for nk_row_layout {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_row_layout {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_popup_buffer {
    pub begin: nk_size,
    pub parent: nk_size,
    pub last: nk_size,
    pub end: nk_size,
    pub active: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nk_popup_buffer() {
    assert_eq!(::std::mem::size_of::<nk_popup_buffer>() , 40usize , concat ! (
               "Size of: " , stringify ! ( nk_popup_buffer ) ));
    assert_eq! (::std::mem::align_of::<nk_popup_buffer>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_popup_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_buffer ) ) . begin as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_buffer ) ,
                "::" , stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_buffer ) ) . parent as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_buffer ) ,
                "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_buffer ) ) . last as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_buffer ) ,
                "::" , stringify ! ( last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_buffer ) ) . end as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_buffer ) ,
                "::" , stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_buffer ) ) . active as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_buffer ) ,
                "::" , stringify ! ( active ) ));
}
impl Clone for nk_popup_buffer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_menu_state {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
    pub offset: nk_scroll,
}
#[test]
fn bindgen_test_layout_nk_menu_state() {
    assert_eq!(::std::mem::size_of::<nk_menu_state>() , 24usize , concat ! (
               "Size of: " , stringify ! ( nk_menu_state ) ));
    assert_eq! (::std::mem::align_of::<nk_menu_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_menu_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_menu_state ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_menu_state ) , "::"
                , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_menu_state ) ) . y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_menu_state ) , "::"
                , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_menu_state ) ) . w as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_menu_state ) , "::"
                , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_menu_state ) ) . h as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_menu_state ) , "::"
                , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_menu_state ) ) . offset as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_menu_state ) , "::"
                , stringify ! ( offset ) ));
}
impl Clone for nk_menu_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct nk_table {
    pub seq: ::std::os::raw::c_uint,
    pub keys: [nk_hash; 60usize],
    pub values: [nk_uint; 60usize],
    pub next: *mut nk_table,
    pub prev: *mut nk_table,
}
#[test]
fn bindgen_test_layout_nk_table() {
    assert_eq!(::std::mem::size_of::<nk_table>() , 504usize , concat ! (
               "Size of: " , stringify ! ( nk_table ) ));
    assert_eq! (::std::mem::align_of::<nk_table>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_table ) ) . seq as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_table ) , "::" ,
                stringify ! ( seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_table ) ) . keys as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_table ) , "::" ,
                stringify ! ( keys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_table ) ) . values as * const _ as
                usize } , 244usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_table ) , "::" ,
                stringify ! ( values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_table ) ) . next as * const _ as usize
                } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_table ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_table ) ) . prev as * const _ as usize
                } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_table ) , "::" ,
                stringify ! ( prev ) ));
}
impl Default for nk_table {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub const nk_window_flags_NK_WINDOW_DYNAMIC: nk_window_flags =
    nk_window_flags::NK_WINDOW_PRIVATE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nk_window_flags {
    NK_WINDOW_PRIVATE = 1024,
    NK_WINDOW_ROM = 2048,
    NK_WINDOW_HIDDEN = 4096,
    NK_WINDOW_CLOSED = 8192,
    NK_WINDOW_MINIMIZED = 16384,
    NK_WINDOW_REMOVE_ROM = 32768,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_popup_state {
    pub win: *mut nk_window,
    pub type_: nk_panel_type,
    pub name: nk_hash,
    pub active: ::std::os::raw::c_int,
    pub combo_count: ::std::os::raw::c_uint,
    pub con_count: ::std::os::raw::c_uint,
    pub con_old: ::std::os::raw::c_uint,
    pub active_con: ::std::os::raw::c_uint,
    pub header: nk_rect,
}
#[test]
fn bindgen_test_layout_nk_popup_state() {
    assert_eq!(::std::mem::size_of::<nk_popup_state>() , 56usize , concat ! (
               "Size of: " , stringify ! ( nk_popup_state ) ));
    assert_eq! (::std::mem::align_of::<nk_popup_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_popup_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_state ) ) . win as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_state ) , "::"
                , stringify ! ( win ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_state ) ) . type_ as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_state ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_state ) ) . name as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_state ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_state ) ) . active as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_state ) , "::"
                , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_state ) ) . combo_count as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_state ) , "::"
                , stringify ! ( combo_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_state ) ) . con_count as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_state ) , "::"
                , stringify ! ( con_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_state ) ) . con_old as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_state ) , "::"
                , stringify ! ( con_old ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_state ) ) . active_con as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_state ) , "::"
                , stringify ! ( active_con ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_popup_state ) ) . header as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_popup_state ) , "::"
                , stringify ! ( header ) ));
}
impl Clone for nk_popup_state {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_popup_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nk_edit_state {
    pub name: nk_hash,
    pub seq: ::std::os::raw::c_uint,
    pub old: ::std::os::raw::c_uint,
    pub active: ::std::os::raw::c_int,
    pub prev: ::std::os::raw::c_int,
    pub cursor: ::std::os::raw::c_int,
    pub sel_start: ::std::os::raw::c_int,
    pub sel_end: ::std::os::raw::c_int,
    pub scrollbar: nk_scroll,
    pub mode: ::std::os::raw::c_uchar,
    pub single_line: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_nk_edit_state() {
    assert_eq!(::std::mem::size_of::<nk_edit_state>() , 44usize , concat ! (
               "Size of: " , stringify ! ( nk_edit_state ) ));
    assert_eq! (::std::mem::align_of::<nk_edit_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nk_edit_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_edit_state ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_edit_state ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_edit_state ) ) . seq as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_edit_state ) , "::"
                , stringify ! ( seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_edit_state ) ) . old as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_edit_state ) , "::"
                , stringify ! ( old ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_edit_state ) ) . active as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_edit_state ) , "::"
                , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_edit_state ) ) . prev as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_edit_state ) , "::"
                , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_edit_state ) ) . cursor as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_edit_state ) , "::"
                , stringify ! ( cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_edit_state ) ) . sel_start as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_edit_state ) , "::"
                , stringify ! ( sel_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_edit_state ) ) . sel_end as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_edit_state ) , "::"
                , stringify ! ( sel_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_edit_state ) ) . scrollbar as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_edit_state ) , "::"
                , stringify ! ( scrollbar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_edit_state ) ) . mode as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_edit_state ) , "::"
                , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_edit_state ) ) . single_line as *
                const _ as usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_edit_state ) , "::"
                , stringify ! ( single_line ) ));
}
impl Clone for nk_edit_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct nk_property_state {
    pub active: ::std::os::raw::c_int,
    pub prev: ::std::os::raw::c_int,
    pub buffer: [::std::os::raw::c_char; 64usize],
    pub length: ::std::os::raw::c_int,
    pub cursor: ::std::os::raw::c_int,
    pub name: nk_hash,
    pub seq: ::std::os::raw::c_uint,
    pub old: ::std::os::raw::c_uint,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nk_property_state() {
    assert_eq!(::std::mem::size_of::<nk_property_state>() , 96usize , concat !
               ( "Size of: " , stringify ! ( nk_property_state ) ));
    assert_eq! (::std::mem::align_of::<nk_property_state>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( nk_property_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_property_state ) ) . active as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_property_state ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_property_state ) ) . prev as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_property_state ) ,
                "::" , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_property_state ) ) . buffer as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_property_state ) ,
                "::" , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_property_state ) ) . length as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_property_state ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_property_state ) ) . cursor as * const
                _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_property_state ) ,
                "::" , stringify ! ( cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_property_state ) ) . name as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_property_state ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_property_state ) ) . seq as * const _
                as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_property_state ) ,
                "::" , stringify ! ( seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_property_state ) ) . old as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_property_state ) ,
                "::" , stringify ! ( old ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_property_state ) ) . state as * const
                _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_property_state ) ,
                "::" , stringify ! ( state ) ));
}
impl Default for nk_property_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_style_item_element {
    pub address: *mut nk_style_item,
    pub old_value: nk_style_item,
}
#[test]
fn bindgen_test_layout_nk_config_stack_style_item_element() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_style_item_element>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( nk_config_stack_style_item_element
               ) ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_style_item_element>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                nk_config_stack_style_item_element ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_style_item_element ) ) .
                address as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_style_item_element ) , "::" , stringify ! (
                address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_style_item_element ) ) .
                old_value as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_style_item_element ) , "::" , stringify ! (
                old_value ) ));
}
impl Clone for nk_config_stack_style_item_element {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_style_item_element {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_float_element {
    pub address: *mut f32,
    pub old_value: f32,
}
#[test]
fn bindgen_test_layout_nk_config_stack_float_element() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_float_element>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( nk_config_stack_float_element ) ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_float_element>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( nk_config_stack_float_element
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_float_element ) ) .
                address as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_float_element ) , "::" , stringify ! ( address
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_float_element ) ) .
                old_value as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_float_element ) , "::" , stringify ! (
                old_value ) ));
}
impl Clone for nk_config_stack_float_element {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_float_element {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_vec2_element {
    pub address: *mut nk_vec2,
    pub old_value: nk_vec2,
}
#[test]
fn bindgen_test_layout_nk_config_stack_vec2_element() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_vec2_element>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( nk_config_stack_vec2_element ) ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_vec2_element>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( nk_config_stack_vec2_element )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_vec2_element ) ) .
                address as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_vec2_element ) , "::" , stringify ! ( address
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_vec2_element ) ) .
                old_value as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_vec2_element ) , "::" , stringify ! (
                old_value ) ));
}
impl Clone for nk_config_stack_vec2_element {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_vec2_element {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_flags_element {
    pub address: *mut nk_flags,
    pub old_value: nk_flags,
}
#[test]
fn bindgen_test_layout_nk_config_stack_flags_element() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_flags_element>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( nk_config_stack_flags_element ) ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_flags_element>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( nk_config_stack_flags_element
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_flags_element ) ) .
                address as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_flags_element ) , "::" , stringify ! ( address
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_flags_element ) ) .
                old_value as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_flags_element ) , "::" , stringify ! (
                old_value ) ));
}
impl Clone for nk_config_stack_flags_element {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_flags_element {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_color_element {
    pub address: *mut nk_color,
    pub old_value: nk_color,
}
#[test]
fn bindgen_test_layout_nk_config_stack_color_element() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_color_element>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( nk_config_stack_color_element ) ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_color_element>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( nk_config_stack_color_element
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_color_element ) ) .
                address as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_color_element ) , "::" , stringify ! ( address
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_color_element ) ) .
                old_value as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_color_element ) , "::" , stringify ! (
                old_value ) ));
}
impl Clone for nk_config_stack_color_element {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_color_element {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_user_font_element {
    pub address: *mut *const nk_user_font,
    pub old_value: *const nk_user_font,
}
#[test]
fn bindgen_test_layout_nk_config_stack_user_font_element() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_user_font_element>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( nk_config_stack_user_font_element )
               ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_user_font_element>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                nk_config_stack_user_font_element ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_user_font_element ) ) .
                address as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_user_font_element ) , "::" , stringify ! (
                address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_user_font_element ) ) .
                old_value as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_user_font_element ) , "::" , stringify ! (
                old_value ) ));
}
impl Clone for nk_config_stack_user_font_element {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_user_font_element {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_button_behavior_element {
    pub address: *mut nk_button_behavior,
    pub old_value: nk_button_behavior,
}
#[test]
fn bindgen_test_layout_nk_config_stack_button_behavior_element() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_button_behavior_element>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               nk_config_stack_button_behavior_element ) ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_button_behavior_element>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                nk_config_stack_button_behavior_element ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_button_behavior_element )
                ) . address as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_button_behavior_element ) , "::" , stringify !
                ( address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_button_behavior_element )
                ) . old_value as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_button_behavior_element ) , "::" , stringify !
                ( old_value ) ));
}
impl Clone for nk_config_stack_button_behavior_element {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_button_behavior_element {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_style_item {
    pub head: ::std::os::raw::c_int,
    pub elements: [nk_config_stack_style_item_element; 16usize],
}
#[test]
fn bindgen_test_layout_nk_config_stack_style_item() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_style_item>() , 648usize
               , concat ! (
               "Size of: " , stringify ! ( nk_config_stack_style_item ) ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_style_item>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( nk_config_stack_style_item )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_style_item ) ) . head as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_style_item ) , "::" , stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_style_item ) ) . elements
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_style_item ) , "::" , stringify ! ( elements )
                ));
}
impl Clone for nk_config_stack_style_item {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_style_item {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_float {
    pub head: ::std::os::raw::c_int,
    pub elements: [nk_config_stack_float_element; 32usize],
}
#[test]
fn bindgen_test_layout_nk_config_stack_float() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_float>() , 520usize ,
               concat ! ( "Size of: " , stringify ! ( nk_config_stack_float )
               ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_float>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_config_stack_float ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_float ) ) . head as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_config_stack_float )
                , "::" , stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_float ) ) . elements as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_config_stack_float )
                , "::" , stringify ! ( elements ) ));
}
impl Clone for nk_config_stack_float {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_float {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_vec2 {
    pub head: ::std::os::raw::c_int,
    pub elements: [nk_config_stack_vec2_element; 16usize],
}
#[test]
fn bindgen_test_layout_nk_config_stack_vec2() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_vec2>() , 264usize ,
               concat ! ( "Size of: " , stringify ! ( nk_config_stack_vec2 )
               ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_vec2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_config_stack_vec2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_vec2 ) ) . head as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_config_stack_vec2 )
                , "::" , stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_vec2 ) ) . elements as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_config_stack_vec2 )
                , "::" , stringify ! ( elements ) ));
}
impl Clone for nk_config_stack_vec2 {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_vec2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_flags {
    pub head: ::std::os::raw::c_int,
    pub elements: [nk_config_stack_flags_element; 32usize],
}
#[test]
fn bindgen_test_layout_nk_config_stack_flags() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_flags>() , 520usize ,
               concat ! ( "Size of: " , stringify ! ( nk_config_stack_flags )
               ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_flags>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_config_stack_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_flags ) ) . head as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_config_stack_flags )
                , "::" , stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_flags ) ) . elements as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_config_stack_flags )
                , "::" , stringify ! ( elements ) ));
}
impl Clone for nk_config_stack_flags {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_flags {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_color {
    pub head: ::std::os::raw::c_int,
    pub elements: [nk_config_stack_color_element; 32usize],
}
#[test]
fn bindgen_test_layout_nk_config_stack_color() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_color>() , 520usize ,
               concat ! ( "Size of: " , stringify ! ( nk_config_stack_color )
               ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_color>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_config_stack_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_color ) ) . head as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_config_stack_color )
                , "::" , stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_color ) ) . elements as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_config_stack_color )
                , "::" , stringify ! ( elements ) ));
}
impl Clone for nk_config_stack_color {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_color {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_user_font {
    pub head: ::std::os::raw::c_int,
    pub elements: [nk_config_stack_user_font_element; 8usize],
}
#[test]
fn bindgen_test_layout_nk_config_stack_user_font() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_user_font>() , 136usize ,
               concat ! (
               "Size of: " , stringify ! ( nk_config_stack_user_font ) ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_user_font>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_config_stack_user_font )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_user_font ) ) . head as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_user_font ) , "::" , stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_user_font ) ) . elements
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_user_font ) , "::" , stringify ! ( elements )
                ));
}
impl Clone for nk_config_stack_user_font {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_user_font {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_config_stack_button_behavior {
    pub head: ::std::os::raw::c_int,
    pub elements: [nk_config_stack_button_behavior_element; 8usize],
}
#[test]
fn bindgen_test_layout_nk_config_stack_button_behavior() {
    assert_eq!(::std::mem::size_of::<nk_config_stack_button_behavior>() ,
               136usize , concat ! (
               "Size of: " , stringify ! ( nk_config_stack_button_behavior )
               ));
    assert_eq! (::std::mem::align_of::<nk_config_stack_button_behavior>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                nk_config_stack_button_behavior ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_button_behavior ) ) .
                head as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_button_behavior ) , "::" , stringify ! ( head
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_config_stack_button_behavior ) ) .
                elements as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                nk_config_stack_button_behavior ) , "::" , stringify ! (
                elements ) ));
}
impl Clone for nk_config_stack_button_behavior {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_config_stack_button_behavior {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_configuration_stacks {
    pub style_items: nk_config_stack_style_item,
    pub floats: nk_config_stack_float,
    pub vectors: nk_config_stack_vec2,
    pub flags: nk_config_stack_flags,
    pub colors: nk_config_stack_color,
    pub fonts: nk_config_stack_user_font,
    pub button_behaviors: nk_config_stack_button_behavior,
}
#[test]
fn bindgen_test_layout_nk_configuration_stacks() {
    assert_eq!(::std::mem::size_of::<nk_configuration_stacks>() , 2744usize ,
               concat ! (
               "Size of: " , stringify ! ( nk_configuration_stacks ) ));
    assert_eq! (::std::mem::align_of::<nk_configuration_stacks>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nk_configuration_stacks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_configuration_stacks ) ) . style_items
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_configuration_stacks
                ) , "::" , stringify ! ( style_items ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_configuration_stacks ) ) . floats as *
                const _ as usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_configuration_stacks
                ) , "::" , stringify ! ( floats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_configuration_stacks ) ) . vectors as
                * const _ as usize } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_configuration_stacks
                ) , "::" , stringify ! ( vectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_configuration_stacks ) ) . flags as *
                const _ as usize } , 1432usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_configuration_stacks
                ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_configuration_stacks ) ) . colors as *
                const _ as usize } , 1952usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_configuration_stacks
                ) , "::" , stringify ! ( colors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_configuration_stacks ) ) . fonts as *
                const _ as usize } , 2472usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_configuration_stacks
                ) , "::" , stringify ! ( fonts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_configuration_stacks ) ) .
                button_behaviors as * const _ as usize } , 2608usize , concat
                ! (
                "Alignment of field: " , stringify ! ( nk_configuration_stacks
                ) , "::" , stringify ! ( button_behaviors ) ));
}
impl Clone for nk_configuration_stacks {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_configuration_stacks {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct nk_page_data {
    pub tbl: __BindgenUnionField<nk_table>,
    pub pan: __BindgenUnionField<nk_panel>,
    pub win: __BindgenUnionField<nk_window>,
    pub bindgen_union_field: [u64; 63usize],
}
#[test]
fn bindgen_test_layout_nk_page_data() {
    assert_eq!(::std::mem::size_of::<nk_page_data>() , 504usize , concat ! (
               "Size of: " , stringify ! ( nk_page_data ) ));
    assert_eq! (::std::mem::align_of::<nk_page_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_page_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_page_data ) ) . tbl as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_page_data ) , "::" ,
                stringify ! ( tbl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_page_data ) ) . pan as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_page_data ) , "::" ,
                stringify ! ( pan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_page_data ) ) . win as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_page_data ) , "::" ,
                stringify ! ( win ) ));
}
impl Clone for nk_page_data {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_page_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct nk_page_element {
    pub data: nk_page_data,
    pub next: *mut nk_page_element,
    pub prev: *mut nk_page_element,
}
#[test]
fn bindgen_test_layout_nk_page_element() {
    assert_eq!(::std::mem::size_of::<nk_page_element>() , 520usize , concat !
               ( "Size of: " , stringify ! ( nk_page_element ) ));
    assert_eq! (::std::mem::align_of::<nk_page_element>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nk_page_element ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_page_element ) ) . data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_page_element ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_page_element ) ) . next as * const _
                as usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_page_element ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_page_element ) ) . prev as * const _
                as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_page_element ) ,
                "::" , stringify ! ( prev ) ));
}
impl Clone for nk_page_element {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_page_element {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct nk_page {
    pub size: ::std::os::raw::c_uint,
    pub next: *mut nk_page,
    pub win: [nk_page_element; 1usize],
}
#[test]
fn bindgen_test_layout_nk_page() {
    assert_eq!(::std::mem::size_of::<nk_page>() , 536usize , concat ! (
               "Size of: " , stringify ! ( nk_page ) ));
    assert_eq! (::std::mem::align_of::<nk_page>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_page ) ) . size as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_page ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_page ) ) . next as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_page ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_page ) ) . win as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_page ) , "::" ,
                stringify ! ( win ) ));
}
impl Clone for nk_page {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_page {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nk_pool {
    pub alloc: nk_allocator,
    pub type_: nk_allocation_type,
    pub page_count: ::std::os::raw::c_uint,
    pub pages: *mut nk_page,
    pub freelist: *mut nk_page_element,
    pub capacity: ::std::os::raw::c_uint,
    pub size: nk_size,
    pub cap: nk_size,
}
#[test]
fn bindgen_test_layout_nk_pool() {
    assert_eq!(::std::mem::size_of::<nk_pool>() , 72usize , concat ! (
               "Size of: " , stringify ! ( nk_pool ) ));
    assert_eq! (::std::mem::align_of::<nk_pool>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nk_pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_pool ) ) . alloc as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_pool ) , "::" ,
                stringify ! ( alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_pool ) ) . type_ as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_pool ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_pool ) ) . page_count as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_pool ) , "::" ,
                stringify ! ( page_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_pool ) ) . pages as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_pool ) , "::" ,
                stringify ! ( pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_pool ) ) . freelist as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_pool ) , "::" ,
                stringify ! ( freelist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_pool ) ) . capacity as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_pool ) , "::" ,
                stringify ! ( capacity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_pool ) ) . size as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_pool ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nk_pool ) ) . cap as * const _ as usize }
                , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( nk_pool ) , "::" ,
                stringify ! ( cap ) ));
}
impl Clone for nk_pool {
    fn clone(&self) -> Self { *self }
}
impl Default for nk_pool {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
